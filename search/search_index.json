{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHY 315 Introduction to Computational Methods in Physics Course Description An introduction to computational and numerical methods in physics. Includes an introduction to version control, documentation, collaborative code writing, and creating scientific quality plots. Numerical methods for differentiation, integration, curve fitting and optimization. Introduction to random variables and Monte Carlo methods. Examples are taken from problems in physics which cannot be solved using analytic methods only. Course Topic Outline Introduction (Programming, Version Control and Documentation) Symbolic Tools and Plotting Numerical Methods for Differentiation and Integration Curve Fitting and Optimization Fourier Transform Monte Carlo Methods Machine Learning Tools","title":"Home"},{"location":"#phy-315-introduction-to-computational-methods-in-physics","text":"","title":"PHY 315 Introduction to Computational Methods in Physics"},{"location":"#course-description","text":"An introduction to computational and numerical methods in physics. Includes an introduction to version control, documentation, collaborative code writing, and creating scientific quality plots. Numerical methods for differentiation, integration, curve fitting and optimization. Introduction to random variables and Monte Carlo methods. Examples are taken from problems in physics which cannot be solved using analytic methods only.","title":"Course Description"},{"location":"#course-topic-outline","text":"Introduction (Programming, Version Control and Documentation) Symbolic Tools and Plotting Numerical Methods for Differentiation and Integration Curve Fitting and Optimization Fourier Transform Monte Carlo Methods Machine Learning Tools","title":"Course Topic Outline"},{"location":"ch1_intro/","text":"Introduction Review of Programming We will mostly make use of the python programming language in this introduction and for much of the course (but not always as we will also look at Mathematica ). Since a basic course in programming is a pre-requisite for this course, some level of familiarity with programming is assumed. The first step is to make sure that you have the proper environment setup on your computer. Make sure that you have python 3 installed; also install the numpy package. One way to make sure that these two packages are installed is to install the Anaconda Python Distribution . Once you have the proper programming environment setup, let's begin with the following example code. Input Output import numpy import numpy as np # (1) print ( np . log10 ( 10 ), np . log ( 10 )) # (2) import the numerical library numpy for mathematical operations np.log10(10) calculates the base-10 logarithm whereas np.log(10) calculates the natural logarithm of 10. print function is used to print the two outputs to the screen. 1.0 2.302585092994046 You should expect two numbers as the output: one for log base 10 i.e. \\(\\log_{\\rm 10}\\) and the other for natural logarithm i.e. \\(\\ln(10)\\) . Let us look at one more example python code to illustrate the use of variables and for loop. Input Output sum of integers from 1 to 100 total = 0 # (1) for i in range ( 1 , 101 ): # (2) total = total + i # (3) print ( total ) # (4) variable total is initially assigned a value of zero note the natural language-like syntax for for loop in python; also, note that range(1, 101) excludes 101 . note that indentation of code is important in python the total variable is printed on the screen once the program exits the for loop after adding 1 to 100. sum of integers from 1 to 100 5050 Version Control Computer codes (and even documents) may require updating at times. At the early stages of developing a computer code, the frequency of updates may be very high. Even for a matured piece of code, there may be maintenance updates that will require you to update the code time and again. Version control tools help us with this process. They can also be useful if we decide to revert a change at a later time and in case that multiple people are collaborating on the same piece of software or document at once. We will make use of github for version control. The underlying version control software utilized by github is called git . Please take the following github skills course to begin. Introduction to GitHub - Github Skills Documentation","title":"Introduction"},{"location":"ch1_intro/#introduction","text":"","title":"Introduction"},{"location":"ch1_intro/#review-of-programming","text":"We will mostly make use of the python programming language in this introduction and for much of the course (but not always as we will also look at Mathematica ). Since a basic course in programming is a pre-requisite for this course, some level of familiarity with programming is assumed. The first step is to make sure that you have the proper environment setup on your computer. Make sure that you have python 3 installed; also install the numpy package. One way to make sure that these two packages are installed is to install the Anaconda Python Distribution . Once you have the proper programming environment setup, let's begin with the following example code. Input Output import numpy import numpy as np # (1) print ( np . log10 ( 10 ), np . log ( 10 )) # (2) import the numerical library numpy for mathematical operations np.log10(10) calculates the base-10 logarithm whereas np.log(10) calculates the natural logarithm of 10. print function is used to print the two outputs to the screen. 1.0 2.302585092994046 You should expect two numbers as the output: one for log base 10 i.e. \\(\\log_{\\rm 10}\\) and the other for natural logarithm i.e. \\(\\ln(10)\\) . Let us look at one more example python code to illustrate the use of variables and for loop. Input Output sum of integers from 1 to 100 total = 0 # (1) for i in range ( 1 , 101 ): # (2) total = total + i # (3) print ( total ) # (4) variable total is initially assigned a value of zero note the natural language-like syntax for for loop in python; also, note that range(1, 101) excludes 101 . note that indentation of code is important in python the total variable is printed on the screen once the program exits the for loop after adding 1 to 100. sum of integers from 1 to 100 5050","title":"Review of Programming"},{"location":"ch1_intro/#version-control","text":"Computer codes (and even documents) may require updating at times. At the early stages of developing a computer code, the frequency of updates may be very high. Even for a matured piece of code, there may be maintenance updates that will require you to update the code time and again. Version control tools help us with this process. They can also be useful if we decide to revert a change at a later time and in case that multiple people are collaborating on the same piece of software or document at once. We will make use of github for version control. The underlying version control software utilized by github is called git . Please take the following github skills course to begin. Introduction to GitHub - Github Skills","title":"Version Control"},{"location":"ch1_intro/#documentation","text":"","title":"Documentation"},{"location":"ch2_symbolic/","text":"Symbolic and Plotting Tools We will consider symbolic math using Mathematica . Alternatives to Mathematica for symbolic mathematics include Maple , symbolic toolbox for Matlab , and the open source python package sympy . Symbolic Math using Mathematica Mathematica is a popular tool for symbolic math, and is useful for many mathematical tasks such as calculating derivatives and integrals. SUNY Plattsburgh students can install Mathematica on their personal computer. See instructions here . Performing mathematical calculations in Mathematica Try typing D[x^2, x] and pressing Shift + Enter to evaluate the cell: Input Output D [ x ^ 2 , x ] 2 x The command D[x^2, x] calculates the derivative of \\(x^2\\) with respect to \\(x\\) . To calculate an integral, use the Integrate command as: Input Output Integrate [ 2 x , x ] x ^ 2 Mathematica can perform many popular integrals that show up in various topics of physics and mathematics. For example: Consider the Gaussian (normal) distribution with one standard deviation ( \\(\\sigma=1\\) ) and zero mean \\((\\mu=0)\\) : \\[ \\mathcal{N}(x) = \\frac{1}{\\sqrt{2 \\pi}} e^{-{x^2}/{2}} \\] Suppose we want to find the integral of this function from \\(-\\infty\\) to \\(\\infty\\) . Such a definite integral will result in the area under the curve between the limits. Following the same syntax as above, using Sqrt[2 Pi] for \\(\\sqrt{2 \\pi}\\) and using Exp[-x^2] for \\(e^{-x^2}\\) , attempt to calculate the definite integral: \\[ \\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , - Infinity , Infinity }] 1 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx =1\\] The factor of \\(1/\\sqrt{2 \\pi}\\) is used to normalize the distribution \\(P(x)\\) so that it can be used as a probability density function (pdf). The integral of a pdf over all possible values should result in one. Now calculate another definite integral of the same integrand but taking the limits from \\(-1\\) to \\(1\\) i.e. calculate the definite integral: \\[ \\frac{1}{\\sqrt{2\\pi}}\\int_{-1}^{1} e^{-x^2/2} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }] Erf [ 1 / Sqrt [ 2 ]] where Erf is the error function . A numerical output in mathematica can be forced by either using N[] or //N as follows: Input Output N [ Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }]] 0.682689 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-1}^1 e^{-x^2/2} dx = {\\rm Erf}\\left[\\frac{1}{\\sqrt{2}}\\right] = 0.682689\\] Using Mathematica now you should be able to obtain the following results: \\[ \\int_{-1}^1 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.682689 \\] \\[ \\int_{-2}^2 \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx = 0.9545 \\] \\[ \\int_{-3}^3 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.9973 \\] Next we will learn some plotting syntax in Mathematica and use them to plot the integrand used above \\(\\mathcal{N}(x)=e^{-x^2/2}/\\sqrt{2 \\pi}\\) to better understand the normal probability density function. Plotting in Mathematica Input Output Plot [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -5 , 5 }, AxesLabel -> { \"x\" , \"N(x)\" }, PlotLabel -> \"Gaussian Distribution\" ] Plotting in Matplotlib The plot of \\(\\mathcal{N}(x)\\) can be made in matplotlib using the following code: Input Output Making plot using matplotlib import matplotlib.pyplot as plt # (1) import numpy as np # (2) x = np . arange ( - 5 , 5 , 0.01 ) # (3) y = np . exp ( - x * x / 2 ) / np . sqrt ( 2 * np . pi ) # (4) plt . plot ( x , y ) # (5) plt . xlabel ( \"$x$\" ) # (6) plt . ylabel ( \"$\\mathcal {N} (x)$\" ) # (7) plt . title ( \"Gaussian Distribution\" ) # (8) plt . show () import the pyplot plotting interface from matplotlib library as plt import the numerical python library numpy as np for various array and mathematical functions create an array from -5 to 5 in increments of 0.01; i.e. \\(\\frac{5-(-5)}{0.01}=1000\\) numbers in total. The number of items in the array x can be checked either using len(x) or using np.size(x) generate a numpy array for \\(y=\\mathcal{N}(x)\\) make the plot using two arrays x and y add label on the x axis add label on the y axis add plot title Example","title":"Symbolic and Plotting Tools"},{"location":"ch2_symbolic/#symbolic-and-plotting-tools","text":"We will consider symbolic math using Mathematica . Alternatives to Mathematica for symbolic mathematics include Maple , symbolic toolbox for Matlab , and the open source python package sympy .","title":"Symbolic and Plotting Tools"},{"location":"ch2_symbolic/#symbolic-math-using-mathematica","text":"Mathematica is a popular tool for symbolic math, and is useful for many mathematical tasks such as calculating derivatives and integrals. SUNY Plattsburgh students can install Mathematica on their personal computer. See instructions here .","title":"Symbolic Math using Mathematica"},{"location":"ch2_symbolic/#performing-mathematical-calculations-in-mathematica","text":"Try typing D[x^2, x] and pressing Shift + Enter to evaluate the cell: Input Output D [ x ^ 2 , x ] 2 x The command D[x^2, x] calculates the derivative of \\(x^2\\) with respect to \\(x\\) . To calculate an integral, use the Integrate command as: Input Output Integrate [ 2 x , x ] x ^ 2 Mathematica can perform many popular integrals that show up in various topics of physics and mathematics. For example: Consider the Gaussian (normal) distribution with one standard deviation ( \\(\\sigma=1\\) ) and zero mean \\((\\mu=0)\\) : \\[ \\mathcal{N}(x) = \\frac{1}{\\sqrt{2 \\pi}} e^{-{x^2}/{2}} \\] Suppose we want to find the integral of this function from \\(-\\infty\\) to \\(\\infty\\) . Such a definite integral will result in the area under the curve between the limits. Following the same syntax as above, using Sqrt[2 Pi] for \\(\\sqrt{2 \\pi}\\) and using Exp[-x^2] for \\(e^{-x^2}\\) , attempt to calculate the definite integral: \\[ \\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , - Infinity , Infinity }] 1 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx =1\\] The factor of \\(1/\\sqrt{2 \\pi}\\) is used to normalize the distribution \\(P(x)\\) so that it can be used as a probability density function (pdf). The integral of a pdf over all possible values should result in one. Now calculate another definite integral of the same integrand but taking the limits from \\(-1\\) to \\(1\\) i.e. calculate the definite integral: \\[ \\frac{1}{\\sqrt{2\\pi}}\\int_{-1}^{1} e^{-x^2/2} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }] Erf [ 1 / Sqrt [ 2 ]] where Erf is the error function . A numerical output in mathematica can be forced by either using N[] or //N as follows: Input Output N [ Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }]] 0.682689 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-1}^1 e^{-x^2/2} dx = {\\rm Erf}\\left[\\frac{1}{\\sqrt{2}}\\right] = 0.682689\\] Using Mathematica now you should be able to obtain the following results: \\[ \\int_{-1}^1 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.682689 \\] \\[ \\int_{-2}^2 \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx = 0.9545 \\] \\[ \\int_{-3}^3 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.9973 \\] Next we will learn some plotting syntax in Mathematica and use them to plot the integrand used above \\(\\mathcal{N}(x)=e^{-x^2/2}/\\sqrt{2 \\pi}\\) to better understand the normal probability density function.","title":"Performing mathematical calculations in Mathematica"},{"location":"ch2_symbolic/#plotting-in-mathematica","text":"Input Output Plot [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -5 , 5 }, AxesLabel -> { \"x\" , \"N(x)\" }, PlotLabel -> \"Gaussian Distribution\" ]","title":"Plotting in Mathematica"},{"location":"ch2_symbolic/#plotting-in-matplotlib","text":"The plot of \\(\\mathcal{N}(x)\\) can be made in matplotlib using the following code: Input Output Making plot using matplotlib import matplotlib.pyplot as plt # (1) import numpy as np # (2) x = np . arange ( - 5 , 5 , 0.01 ) # (3) y = np . exp ( - x * x / 2 ) / np . sqrt ( 2 * np . pi ) # (4) plt . plot ( x , y ) # (5) plt . xlabel ( \"$x$\" ) # (6) plt . ylabel ( \"$\\mathcal {N} (x)$\" ) # (7) plt . title ( \"Gaussian Distribution\" ) # (8) plt . show () import the pyplot plotting interface from matplotlib library as plt import the numerical python library numpy as np for various array and mathematical functions create an array from -5 to 5 in increments of 0.01; i.e. \\(\\frac{5-(-5)}{0.01}=1000\\) numbers in total. The number of items in the array x can be checked either using len(x) or using np.size(x) generate a numpy array for \\(y=\\mathcal{N}(x)\\) make the plot using two arrays x and y add label on the x axis add label on the y axis add plot title","title":"Plotting in Matplotlib"},{"location":"ch2_symbolic/#example","text":"","title":"Example"},{"location":"ch3_numeric/","text":"Numerical Methods for Differentiation and Integration First, let us look into some methods for calculating numerical derivatives. Finite Differences Numerical derivatives of a function \\(f(x)\\) at \\(x=x_0\\) can be calculated by the method of finite differences. Recall that the derivative \\(f'(x_0)\\) tells you about the slope of the tangent at \\(x=x_0\\) . Such a slope can be drawn by drawing a line by considering two nearby points on either side of \\(P(x_0, f(x_0))\\) : \\(P_-(x_0-h, f(x_0-h))\\) and \\(P_+(x_0+h, f(x_0+h))\\) where \\(h\\) is small. Therefore, the estimate for the slope and therefore the derivative \\(f'(x_0)\\) becomes: \\[f'(x_0) = \\frac{f(x_0+h)-f(x_0-h)}{x_0+h-(x_0-h)}=\\frac{f(x_0+h)-f(x_0-h)}{2 h}\\] You should convince yourself that as \\(h\\rightarrow 0\\) , your estimate approaches the exact derivative. Sample code and accuracy check Python code for central difference Accuracy check central difference derivative def central_diff_sin ( x , h ): \"\"\"Calculate numerical derivative of sin(x) using central difference Parameters ---------- x : real angle in radians h : real step size in radians \"\"\" import numpy as np return ( np . sin ( x + h ) - np . sin ( x - h )) / ( 2 * h ) x h central_diff_sin(x,h) cos(x) (actual) percent accuracy 0.3 0.04 0.9550818 0.9553365 0.026660 0.3 0.03 0.9551932 0.9553365 0.014999 0.3 0.02 0.9552728 0.9553365 0.006667 0.3 0.01 0.9553206 0.9553365 0.001663 Estimating accuracy In the example above, we knew the correct value of the operation that we were numerically calculating since \\(\\frac{d\\sin(x)}{dx} = \\cos x\\) . However, the actual value of the numerical methods lies when calculating quantities that do not have an easy analytic solution. In such cases, it is useful to be able to have some knowledge of the error in the numerical estimate. We can estimate the error made when numerically calculating derivatives using the central difference method by using Taylor expansion. Leading order error for central difference Proof using Taylor expansion The leading order approximation error is given by \\[\\epsilon = \\frac{|h^2 f'''(x_0)|}{6}\\] The expression shows that the approximation error \\(\\epsilon\\) decreases as \\(h\\) decreases. For our example above with \\(f(x)=\\sin(x)\\) , \\(x_0=0.3\\) and \\(h=0.01\\) : \\[\\epsilon = \\frac{|(0.01)^2 (\\cos{0.1})|}{6} = 0.00001658 = 0.001658\\% \\] which is close to the actual percent accuracy calculated earlier. \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] we obtain, \\[ \\frac{f(x_0+h)-f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2 f'''(x_0)}{6} + \\dots \\] Numerical Integration Numerical integrations are commonplace in scientific modeling and simulations. If several integrations have to be calculated, not only accuracy and precision but the speed at which those can be obtained becomes important. We will attempt to understand all three concepts (accuracy, precision and the speed of calculation) in the context of three methods of numerical integrations given below. Working with one dimensional integrals, our goal will be to approximate the definite integral: \\[ I(a, b) = \\int_a^b f(x)\\ dx. \\] Trapezoid rule In the trapezoid rule, the integral is approximated by adding the areas of many trapezoids. Simpson's rule Adaptive Integration Examples and Exercises Work out a forward difference approach (i.e. use the slope of line made by \\(P_+\\) and \\(P\\) ) to taking numerical derivative and compare it with the central difference method discussed above in terms of accuracy. Suppose you have a sampled function i.e. the function values are known (let's say at a regular interval of \\(h\\) ). Which one is a better approach -- central difference or forward difference for calculating numerical derivatives?","title":"Numerical Methods"},{"location":"ch3_numeric/#numerical-methods-for-differentiation-and-integration","text":"First, let us look into some methods for calculating numerical derivatives.","title":"Numerical Methods for Differentiation and Integration"},{"location":"ch3_numeric/#finite-differences","text":"Numerical derivatives of a function \\(f(x)\\) at \\(x=x_0\\) can be calculated by the method of finite differences. Recall that the derivative \\(f'(x_0)\\) tells you about the slope of the tangent at \\(x=x_0\\) . Such a slope can be drawn by drawing a line by considering two nearby points on either side of \\(P(x_0, f(x_0))\\) : \\(P_-(x_0-h, f(x_0-h))\\) and \\(P_+(x_0+h, f(x_0+h))\\) where \\(h\\) is small. Therefore, the estimate for the slope and therefore the derivative \\(f'(x_0)\\) becomes: \\[f'(x_0) = \\frac{f(x_0+h)-f(x_0-h)}{x_0+h-(x_0-h)}=\\frac{f(x_0+h)-f(x_0-h)}{2 h}\\] You should convince yourself that as \\(h\\rightarrow 0\\) , your estimate approaches the exact derivative.","title":"Finite Differences"},{"location":"ch3_numeric/#sample-code-and-accuracy-check","text":"Python code for central difference Accuracy check central difference derivative def central_diff_sin ( x , h ): \"\"\"Calculate numerical derivative of sin(x) using central difference Parameters ---------- x : real angle in radians h : real step size in radians \"\"\" import numpy as np return ( np . sin ( x + h ) - np . sin ( x - h )) / ( 2 * h ) x h central_diff_sin(x,h) cos(x) (actual) percent accuracy 0.3 0.04 0.9550818 0.9553365 0.026660 0.3 0.03 0.9551932 0.9553365 0.014999 0.3 0.02 0.9552728 0.9553365 0.006667 0.3 0.01 0.9553206 0.9553365 0.001663","title":"Sample code and accuracy check"},{"location":"ch3_numeric/#estimating-accuracy","text":"In the example above, we knew the correct value of the operation that we were numerically calculating since \\(\\frac{d\\sin(x)}{dx} = \\cos x\\) . However, the actual value of the numerical methods lies when calculating quantities that do not have an easy analytic solution. In such cases, it is useful to be able to have some knowledge of the error in the numerical estimate. We can estimate the error made when numerically calculating derivatives using the central difference method by using Taylor expansion. Leading order error for central difference Proof using Taylor expansion The leading order approximation error is given by \\[\\epsilon = \\frac{|h^2 f'''(x_0)|}{6}\\] The expression shows that the approximation error \\(\\epsilon\\) decreases as \\(h\\) decreases. For our example above with \\(f(x)=\\sin(x)\\) , \\(x_0=0.3\\) and \\(h=0.01\\) : \\[\\epsilon = \\frac{|(0.01)^2 (\\cos{0.1})|}{6} = 0.00001658 = 0.001658\\% \\] which is close to the actual percent accuracy calculated earlier. \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] we obtain, \\[ \\frac{f(x_0+h)-f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2 f'''(x_0)}{6} + \\dots \\]","title":"Estimating accuracy"},{"location":"ch3_numeric/#numerical-integration","text":"Numerical integrations are commonplace in scientific modeling and simulations. If several integrations have to be calculated, not only accuracy and precision but the speed at which those can be obtained becomes important. We will attempt to understand all three concepts (accuracy, precision and the speed of calculation) in the context of three methods of numerical integrations given below. Working with one dimensional integrals, our goal will be to approximate the definite integral: \\[ I(a, b) = \\int_a^b f(x)\\ dx. \\]","title":"Numerical Integration"},{"location":"ch3_numeric/#trapezoid-rule","text":"In the trapezoid rule, the integral is approximated by adding the areas of many trapezoids.","title":"Trapezoid rule"},{"location":"ch3_numeric/#simpsons-rule","text":"","title":"Simpson's rule"},{"location":"ch3_numeric/#adaptive-integration","text":"","title":"Adaptive Integration"},{"location":"ch3_numeric/#examples-and-exercises","text":"Work out a forward difference approach (i.e. use the slope of line made by \\(P_+\\) and \\(P\\) ) to taking numerical derivative and compare it with the central difference method discussed above in terms of accuracy. Suppose you have a sampled function i.e. the function values are known (let's say at a regular interval of \\(h\\) ). Which one is a better approach -- central difference or forward difference for calculating numerical derivatives?","title":"Examples and Exercises"},{"location":"ch4_fitting/","text":"Curve fitting and Optimization Least square polynomial fitting Local Optimization Global Optimization","title":"Curve Fitting and Optimization"},{"location":"ch4_fitting/#curve-fitting-and-optimization","text":"","title":"Curve fitting and Optimization"},{"location":"ch4_fitting/#least-square-polynomial-fitting","text":"","title":"Least square polynomial fitting"},{"location":"ch4_fitting/#local-optimization","text":"","title":"Local Optimization"},{"location":"ch4_fitting/#global-optimization","text":"","title":"Global Optimization"},{"location":"ch5_fouriertransform/","text":"Fourier Transform and its Applications","title":"Fourier Transform"},{"location":"ch5_fouriertransform/#fourier-transform-and-its-applications","text":"","title":"Fourier Transform and its Applications"},{"location":"ch6_montecarlo/","text":"Monte Carlo Methods Random numbers Consider the output of the following code: random module import random random . seed ( 1000 ) print ( random . random (), random . random ()) The output will be two numbers printed on the screen. The random.random() command gives you a random number in the range [0.0, 1.0) . The likelihood of getting a particular value between 0 and 1 is the same. In statistical language, such a likelihood/probability is called a uniform distribution. If you want to get a random number in a different range, say [a, b] , you can either use the result of random . random () and rescale it appropriately, or directly use the function random . uniform ( a , b ) . Use of random . seed () : If you use the same seed number (argument) in calling random . seed ( seed ) before calling random . random () , the output is identical for the same seed . Because the returned random numbers depend on the seed , the number generator used by the random module is called a pseudo- random number generator. Such a generator is useful if you have to reproduce results (e.g. simulation) at a later time. If you do not provide an argument to random.seed or set random.seed(None) , the current system time is used as a proxy to a random seed and you will get different results each time you call random.random() . Estimating area using random numbers We can make use of random numbers to estimate areas. Suppose we want to estimate the area of the unit circle. Area of a unit circle \\[ A = \\pi r ^2 = \\pi (1)^2 = \\pi \\] In this case, we know the answer is \\(\\pi\\) . Therefore, we can frame this exercise as a method to estimate the numerical value of \\(\\pi\\) as well. Consider a unit circle embedded in a square. Now, in each step, we will generate two random numbers \\((x, y)\\) inside the embedding square, and check whether this randomly generated point lies inside of the unit circle or outside. Then an estimate of the area of the unit circle can be made: \\[ A = \\left( \\frac{\\rm points\\ inside\\ the\\ circle}{\\rm total\\ points} \\right) \\times {\\rm area\\ of\\ embedding\\ square}\\] Points Inside: 0 Total Points: 0 Area Estimate: Refresh the page to estimate using a new set of random points. var canvas = document.getElementById('canvas1') if (canvas.getContext) { var ctx = canvas.getContext('2d'); } ctx.beginPath(); ctx.strokeStyle=\"blue\"; ctx.rect(50, 50, 200, 200); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=\"red\"; ctx.arc(150, 150, 100, 2*Math.PI, false); ctx.stroke(); let pts = 0; let total = 0; function randomPoint() { x = Math.random()*200+50; y = Math.random()*200+50; if ((x-150)*(x-150)+(y-150)*(y-150)<=10000) { pts = pts + 1; ctx.fillStyle=\"green\"; } else { ctx.fillStyle=\"blue\"; } total = total + 1; ctx.fillRect(x, y, 1, 1); document.getElementById('label1').innerHTML = pts; document.getElementById('label2').innerHTML = total; Area = 4*pts/total document.getElementById('Aest').innerHTML = Area; } for (let i = 0; i < 100000; i++) { setTimeout(function() { randomPoint();}, 0); } Python code to estimate \\(\\pi\\) Estimate area of a unit circle def pi_estimate ( total = 1000 ): pts_in = 0 for i in range ( total ): x = random . uniform ( - 1 , 1 ) y = random . uniform ( - 1 , 1 ) if ( x ** 2.0 + y ** 2.0 <= 1.0 ): pts_in = pts_in + 1.0 return 4.0 * pts_in / total print ( pi_estimate ()) Increasing the number of points used through the total argument in the pi_estimate function improves the estimate. If \\(N\\) is the number of points used, the standard error scales as \\(1/\\sqrt{N}\\) . Monte Carlo Integration Markov Chain Monte Carlo (MCMC) Examples","title":"Monte Carlo Methods"},{"location":"ch6_montecarlo/#monte-carlo-methods","text":"","title":"Monte Carlo Methods"},{"location":"ch6_montecarlo/#random-numbers","text":"Consider the output of the following code: random module import random random . seed ( 1000 ) print ( random . random (), random . random ()) The output will be two numbers printed on the screen. The random.random() command gives you a random number in the range [0.0, 1.0) . The likelihood of getting a particular value between 0 and 1 is the same. In statistical language, such a likelihood/probability is called a uniform distribution. If you want to get a random number in a different range, say [a, b] , you can either use the result of random . random () and rescale it appropriately, or directly use the function random . uniform ( a , b ) . Use of random . seed () : If you use the same seed number (argument) in calling random . seed ( seed ) before calling random . random () , the output is identical for the same seed . Because the returned random numbers depend on the seed , the number generator used by the random module is called a pseudo- random number generator. Such a generator is useful if you have to reproduce results (e.g. simulation) at a later time. If you do not provide an argument to random.seed or set random.seed(None) , the current system time is used as a proxy to a random seed and you will get different results each time you call random.random() .","title":"Random numbers"},{"location":"ch6_montecarlo/#estimating-area-using-random-numbers","text":"We can make use of random numbers to estimate areas. Suppose we want to estimate the area of the unit circle. Area of a unit circle \\[ A = \\pi r ^2 = \\pi (1)^2 = \\pi \\] In this case, we know the answer is \\(\\pi\\) . Therefore, we can frame this exercise as a method to estimate the numerical value of \\(\\pi\\) as well. Consider a unit circle embedded in a square. Now, in each step, we will generate two random numbers \\((x, y)\\) inside the embedding square, and check whether this randomly generated point lies inside of the unit circle or outside. Then an estimate of the area of the unit circle can be made: \\[ A = \\left( \\frac{\\rm points\\ inside\\ the\\ circle}{\\rm total\\ points} \\right) \\times {\\rm area\\ of\\ embedding\\ square}\\] Points Inside: 0 Total Points: 0 Area Estimate: Refresh the page to estimate using a new set of random points. var canvas = document.getElementById('canvas1') if (canvas.getContext) { var ctx = canvas.getContext('2d'); } ctx.beginPath(); ctx.strokeStyle=\"blue\"; ctx.rect(50, 50, 200, 200); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=\"red\"; ctx.arc(150, 150, 100, 2*Math.PI, false); ctx.stroke(); let pts = 0; let total = 0; function randomPoint() { x = Math.random()*200+50; y = Math.random()*200+50; if ((x-150)*(x-150)+(y-150)*(y-150)<=10000) { pts = pts + 1; ctx.fillStyle=\"green\"; } else { ctx.fillStyle=\"blue\"; } total = total + 1; ctx.fillRect(x, y, 1, 1); document.getElementById('label1').innerHTML = pts; document.getElementById('label2').innerHTML = total; Area = 4*pts/total document.getElementById('Aest').innerHTML = Area; } for (let i = 0; i < 100000; i++) { setTimeout(function() { randomPoint();}, 0); } Python code to estimate \\(\\pi\\) Estimate area of a unit circle def pi_estimate ( total = 1000 ): pts_in = 0 for i in range ( total ): x = random . uniform ( - 1 , 1 ) y = random . uniform ( - 1 , 1 ) if ( x ** 2.0 + y ** 2.0 <= 1.0 ): pts_in = pts_in + 1.0 return 4.0 * pts_in / total print ( pi_estimate ()) Increasing the number of points used through the total argument in the pi_estimate function improves the estimate. If \\(N\\) is the number of points used, the standard error scales as \\(1/\\sqrt{N}\\) .","title":"Estimating area using random numbers"},{"location":"ch6_montecarlo/#monte-carlo-integration","text":"","title":"Monte Carlo Integration"},{"location":"ch6_montecarlo/#markov-chain-monte-carlo-mcmc","text":"","title":"Markov Chain Monte Carlo (MCMC)"},{"location":"ch6_montecarlo/#examples","text":"","title":"Examples"},{"location":"ch7_mltools/","text":"Machine Learning Tools Classification using ready-made ML tools Example","title":"Machine Learning Example"},{"location":"ch7_mltools/#machine-learning-tools","text":"","title":"Machine Learning Tools"},{"location":"ch7_mltools/#classification-using-ready-made-ml-tools","text":"","title":"Classification using ready-made ML tools"},{"location":"ch7_mltools/#example","text":"","title":"Example"},{"location":"references/","text":"Resources for further reading and reference Books Numerical Methods in Physics with Python by Alex Gezerlis Computational Physics by Mark Newman Numerical Computing with MATLAB by Cleve Moler Tools used to prepare materials and write these notes Markdown Mkdocs Mkdocs material Python Numpy Mathematica Github and github pages Linux Jupyter notebook HTML and Javascript Other useful references Creating Interactive Web Simulations Using HTML5 and JavaScript by Daniel V. Schroeder The Markov-chain Monte Carlo Interactive Gallery by Chi Feng","title":"Further References"},{"location":"references/#resources-for-further-reading-and-reference","text":"","title":"Resources for further reading and reference"},{"location":"references/#books","text":"Numerical Methods in Physics with Python by Alex Gezerlis Computational Physics by Mark Newman Numerical Computing with MATLAB by Cleve Moler","title":"Books"},{"location":"references/#tools-used-to-prepare-materials-and-write-these-notes","text":"Markdown Mkdocs Mkdocs material Python Numpy Mathematica Github and github pages Linux Jupyter notebook HTML and Javascript","title":"Tools used to prepare materials and write these notes"},{"location":"references/#other-useful-references","text":"Creating Interactive Web Simulations Using HTML5 and JavaScript by Daniel V. Schroeder The Markov-chain Monte Carlo Interactive Gallery by Chi Feng","title":"Other useful references"}]}
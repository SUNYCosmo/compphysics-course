{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHY 315 Introduction to Computational Methods in Physics Course Description An introduction to computational and numerical methods in physics. Includes an introduction to version control, documentation, collaborative code writing, and creating scientific quality plots. Numerical methods for differentiation, integration, curve fitting and optimization. Introduction to random variables and Monte Carlo methods. Examples are taken from problems in physics which cannot be solved using analytic methods only. Course Topic Outline Introduction (Programming, Version Control and Documentation) Symbolic Tools and Plotting Numerical Methods for Differentiation Numerical Methods for Integration Random numbers and Monte-carlo integration Differential Equations Fourier Transform","title":"Home"},{"location":"#phy-315-introduction-to-computational-methods-in-physics","text":"","title":"PHY 315 Introduction to Computational Methods in Physics"},{"location":"#course-description","text":"An introduction to computational and numerical methods in physics. Includes an introduction to version control, documentation, collaborative code writing, and creating scientific quality plots. Numerical methods for differentiation, integration, curve fitting and optimization. Introduction to random variables and Monte Carlo methods. Examples are taken from problems in physics which cannot be solved using analytic methods only.","title":"Course Description"},{"location":"#course-topic-outline","text":"Introduction (Programming, Version Control and Documentation) Symbolic Tools and Plotting Numerical Methods for Differentiation Numerical Methods for Integration Random numbers and Monte-carlo integration Differential Equations Fourier Transform","title":"Course Topic Outline"},{"location":"ch_diffequations/","text":"Differential Equations In physics, we encounter many differential equations -- Newton's second law in introductory mechanics and Schrodinger's equation in modern physics being some examples. Only a small subset of differential equations can be solved analytically and therefore numerical methods are important in solving many problems that require one to solve differential equations which do not have known anaytic solutions. Euler's method A simple method to estimate a numerical solution \\(x(t)\\) to the differential equation \\[\\frac{dx}{dt} = f(x,t)\\] can be devised by Taylor expanding \\(x(t+h)\\) about \\(t\\) . \\[ x(t+h) = x(t) + h \\frac{dx}{dt} + \\frac{h^2}{2} \\frac{d^2 x}{dt^2} + \\dots \\] where \\(h\\) is a small time step near \\(t\\) . Taylor expansion Recall the formula for Taylor expansion of \\(g(y)\\) about \\(y=y_0\\) . \\[ g(y) = g(y_0) + g'(y_0) (y-y_0) + \\frac{g''(y_0)}{2!} (y-y_0)^2 + \\dots\\] For small \\(h\\) , we may estimate \\(x(t+h)\\) given that we know \\(x(t)\\) by truncating the above Taylor series as: Euler's method \\[ x(t+h) \\approx x(t) + h f(x,t) \\] The approximate error we make is \\(\\frac{1}{2}h^2 \\frac{d^2x}{dt^2}\\) , which is the largest term that we ignore from the Taylor series expansion of \\(x(t+h)\\) . The error per step is therefore \\(\\mathcal{O}(h^2)\\) . If we were to use Euler's method to find a numerical solution for \\(x(t)\\) from \\(t=a\\) to \\(t=b\\) in steps of \\(h\\) , then we can define and estimate the cumulative error as: \\[ \\sum_{k=0}^{N-1} \\frac{1}{2} h^2 \\left( \\frac{d^2 x}{dt^2} \\right)_{t=a+kh} = \\frac{h}{2} \\sum_{k=0}^{N-1} h \\left( \\frac{df}{dt}\\right)_{t=a+k h} \\] The sum can be approximated by an integral from small \\(h\\) to obtain \\[ \\frac{1}{2} h \\int_a^b \\frac{df}{dt} dt = \\frac{h}{2} \\left[ f(x(b), b) - f(x(a), a) \\right] \\] That is the cumulative error is \\(O(h)\\) and not \\(O(h^2)\\) . Second-order Runge-Kutta method The second-order Runge-Kutta method can be derived by performing Taylor expansion of \\(x(t+h)\\) and \\(x(t)\\) around \\(t+h/2\\) , to obtain \\[ x(t+h) = x(t) + h\\left( \\frac{dx}{dt} \\right)_{t+h/2} + \\mathcal{O}(h^3)\\] But \\[ \\left(\\frac{dx}{dt} \\right)_{t+h/2} = f(x(t+h/2), h/2) \\] As such, we can write the second-order Runge-Kutta method as: Second-order Runge Kutta method \\[ x(t+h) = x(t) + k_2 \\] where, \\(k_2 = h f(x+\\frac{k_1}{2}, t+h/2)\\) and \\(k_1 = h f(x,t)\\) In writing a code you will have to evaluate \\(k_1\\) first, followed by \\(k_2\\) , and then find \\(x(t+h)\\) given the knowledge of \\(x(t)\\) and the function \\(f(x,t)\\) . Fourth-order Runge-Kutta method Following the same method and approach, one can derive third-order, fourth-order and higher-order Runge-Kutta methods. The fourth-order Runge-Kutta method is a popular numerical method of solving differential equations numerically: Fourth-order Runge-Kutta method \\[ \\begin{align} k_1 &= h f(x,t) \\\\ k_2 &= hf\\left(x+\\frac{1}{2}k_1), t + \\frac{1}{2}h\\right) \\\\ k_3 &= h f \\left(x + \\frac{1}{2}k_2, t + \\frac{1}{2} h \\right) \\\\ k_4 &= h f\\left(x+k_3, t+h\\right) \\\\ x(t+h) &= x(t) + \\frac{1}{6}\\left(k_1+2k_2+2k_3+k_4\\right)\\end{align} \\]","title":"Differential Equations"},{"location":"ch_diffequations/#differential-equations","text":"In physics, we encounter many differential equations -- Newton's second law in introductory mechanics and Schrodinger's equation in modern physics being some examples. Only a small subset of differential equations can be solved analytically and therefore numerical methods are important in solving many problems that require one to solve differential equations which do not have known anaytic solutions.","title":"Differential Equations"},{"location":"ch_diffequations/#eulers-method","text":"A simple method to estimate a numerical solution \\(x(t)\\) to the differential equation \\[\\frac{dx}{dt} = f(x,t)\\] can be devised by Taylor expanding \\(x(t+h)\\) about \\(t\\) . \\[ x(t+h) = x(t) + h \\frac{dx}{dt} + \\frac{h^2}{2} \\frac{d^2 x}{dt^2} + \\dots \\] where \\(h\\) is a small time step near \\(t\\) . Taylor expansion Recall the formula for Taylor expansion of \\(g(y)\\) about \\(y=y_0\\) . \\[ g(y) = g(y_0) + g'(y_0) (y-y_0) + \\frac{g''(y_0)}{2!} (y-y_0)^2 + \\dots\\] For small \\(h\\) , we may estimate \\(x(t+h)\\) given that we know \\(x(t)\\) by truncating the above Taylor series as: Euler's method \\[ x(t+h) \\approx x(t) + h f(x,t) \\] The approximate error we make is \\(\\frac{1}{2}h^2 \\frac{d^2x}{dt^2}\\) , which is the largest term that we ignore from the Taylor series expansion of \\(x(t+h)\\) . The error per step is therefore \\(\\mathcal{O}(h^2)\\) . If we were to use Euler's method to find a numerical solution for \\(x(t)\\) from \\(t=a\\) to \\(t=b\\) in steps of \\(h\\) , then we can define and estimate the cumulative error as: \\[ \\sum_{k=0}^{N-1} \\frac{1}{2} h^2 \\left( \\frac{d^2 x}{dt^2} \\right)_{t=a+kh} = \\frac{h}{2} \\sum_{k=0}^{N-1} h \\left( \\frac{df}{dt}\\right)_{t=a+k h} \\] The sum can be approximated by an integral from small \\(h\\) to obtain \\[ \\frac{1}{2} h \\int_a^b \\frac{df}{dt} dt = \\frac{h}{2} \\left[ f(x(b), b) - f(x(a), a) \\right] \\] That is the cumulative error is \\(O(h)\\) and not \\(O(h^2)\\) .","title":"Euler's method"},{"location":"ch_diffequations/#second-order-runge-kutta-method","text":"The second-order Runge-Kutta method can be derived by performing Taylor expansion of \\(x(t+h)\\) and \\(x(t)\\) around \\(t+h/2\\) , to obtain \\[ x(t+h) = x(t) + h\\left( \\frac{dx}{dt} \\right)_{t+h/2} + \\mathcal{O}(h^3)\\] But \\[ \\left(\\frac{dx}{dt} \\right)_{t+h/2} = f(x(t+h/2), h/2) \\] As such, we can write the second-order Runge-Kutta method as: Second-order Runge Kutta method \\[ x(t+h) = x(t) + k_2 \\] where, \\(k_2 = h f(x+\\frac{k_1}{2}, t+h/2)\\) and \\(k_1 = h f(x,t)\\) In writing a code you will have to evaluate \\(k_1\\) first, followed by \\(k_2\\) , and then find \\(x(t+h)\\) given the knowledge of \\(x(t)\\) and the function \\(f(x,t)\\) .","title":"Second-order Runge-Kutta method"},{"location":"ch_diffequations/#fourth-order-runge-kutta-method","text":"Following the same method and approach, one can derive third-order, fourth-order and higher-order Runge-Kutta methods. The fourth-order Runge-Kutta method is a popular numerical method of solving differential equations numerically: Fourth-order Runge-Kutta method \\[ \\begin{align} k_1 &= h f(x,t) \\\\ k_2 &= hf\\left(x+\\frac{1}{2}k_1), t + \\frac{1}{2}h\\right) \\\\ k_3 &= h f \\left(x + \\frac{1}{2}k_2, t + \\frac{1}{2} h \\right) \\\\ k_4 &= h f\\left(x+k_3, t+h\\right) \\\\ x(t+h) &= x(t) + \\frac{1}{6}\\left(k_1+2k_2+2k_3+k_4\\right)\\end{align} \\]","title":"Fourth-order Runge-Kutta method"},{"location":"ch_fitting/","text":"Curve fitting and Optimization Least square polynomial fitting Local Optimization Global Optimization","title":"Curve fitting and Optimization"},{"location":"ch_fitting/#curve-fitting-and-optimization","text":"","title":"Curve fitting and Optimization"},{"location":"ch_fitting/#least-square-polynomial-fitting","text":"","title":"Least square polynomial fitting"},{"location":"ch_fitting/#local-optimization","text":"","title":"Local Optimization"},{"location":"ch_fitting/#global-optimization","text":"","title":"Global Optimization"},{"location":"ch_fouriertransform/","text":"Fourier Transform and its Applications Fourier Series Any 1D function \\(f(x)\\) in the interval \\(0\\leq x < L\\) can be written down as a series of sines and cosines: \\[ f(x) = \\sum_{i=0}^\\infty a_j \\cos\\left(\\frac{2 \\pi j x}{L}\\right) + \\sum_{j=0}^\\infty b_j \\sin\\left( \\frac{2 \\pi j x}{L} \\right) \\] given that all the coefficients \\(a_i\\) 's and \\(b_j\\) 's are known. Using the identities that relate the sines and cosines to exponential, it is possible to write the series using complex exponential: \\[ f(x) = \\sum_{i=-\\infty}^\\infty c_j \\exp \\left( i \\left[\\frac{2 \\pi j x}{L}\\right] \\right) \\] where the sum limit now goes from \\(-\\infty\\) to \\(\\infty\\) . The coefficients \\(c_j\\) s can be obtained by using the orthogonality of the complex exponential \\[\\int_0^L e^{i \\left[\\frac{2 \\pi j}{L}\\right] x} e^{-i \\left[\\frac{2 \\pi j'}{L}\\right] x} dx = L \\delta(j-j')\\] \\[ c_j = \\frac{1}{L} \\int_{0}^L f(x) \\exp \\left( - i \\left[ \\frac{2 \\pi j x}{L} \\right] \\right) \\] Therefore, we can represent the function \\(f(x)\\) as the coefficients of Fourier series \\(\\{ c_j \\}\\) . Given one representation we can find the other and vice versa. Discrete fourier transform In many practical applications, fourier transforms of discretely sampled data points is useful. Discrete fourier transform of a set of n-data points \\(\\{a_0, a_1, a_2, \\dots, a_{n-1}\\}\\) is defined as: Discrete Fourier Transform \\[ A_k = \\sum_{m=0}^{n-1} a_m \\exp{ \\left\\{ - 2 \\pi i \\left[ \\frac{m k}{n} \\right] \\right\\}} \\] Here \\(A_k\\) are the fourier coefficients (n of them). From these fourier coefficients, we can get back the initial data points \\(a_m\\) s through an inverse discrete fourier transform: Inverse Discrete Fourier Transform \\[ a_m = \\frac{1}{n} \\sum_{k=0}^{n-1} A_k \\exp{ \\left\\{ 2 \\pi i \\left[ \\frac{m k}{n} \\right] \\right\\}} \\] It is possible to implement a direct version of this formula in python as python supports complex numbers. For instance the complex number \\(i\\) is implemented in python using 1j . However, as \\(n\\) increases these direct implementations of DFT will take a long time to evaluate as the number of operations go as \\(\\mathcal{O}(n^2)\\) . As such, a more clever algrithm called the fast fourier transform are implemented in software packages that calculate discrete fourier transform. For example, numpy has numpy.fft.fft and numpy.fft.rfft functions that are useful to calculate fourier transforms. Time series sunspot data Implement your own discrete fourier transform dft function and use it to fourier transform the time series sunspot data . To understand the result, notice that if our data is a time series as is the sunspot data (number of sunspots each month), then the fourier transform gives us a measure of the frequency. First, notice that when \\(k=0\\) , the fourier transform \\(A_0\\) is just the average of the data points: \\[ A_0 = \\frac{1}{n} \\sum_{m=0}^{n-1} a_m \\] We can think of this as a wave with zero frequency. Second, when \\(k=1\\) , we start to get the coefficient of the Fourier wave decomposition with frequency \\(f_1 = \\frac{1}{n \\Delta t}\\) , and the frequency increases with increasing \\(k\\) . In general: \\[ f_k = \\frac{k}{n \\Delta t} \\] In the sunspot data \\(\\Delta t = 1\\ {\\rm month}\\) . By plotting the power spectrum \\(p_k = |A_k|^2 = A_k^* A_k\\) of the Fourier coefficients, and finding out the \\(k\\) at which it is maximum, it is possible to find the periodicity of the sunspot data using \\(T= 1/f\\) .","title":"Fourier Transform"},{"location":"ch_fouriertransform/#fourier-transform-and-its-applications","text":"","title":"Fourier Transform and its Applications"},{"location":"ch_fouriertransform/#fourier-series","text":"Any 1D function \\(f(x)\\) in the interval \\(0\\leq x < L\\) can be written down as a series of sines and cosines: \\[ f(x) = \\sum_{i=0}^\\infty a_j \\cos\\left(\\frac{2 \\pi j x}{L}\\right) + \\sum_{j=0}^\\infty b_j \\sin\\left( \\frac{2 \\pi j x}{L} \\right) \\] given that all the coefficients \\(a_i\\) 's and \\(b_j\\) 's are known. Using the identities that relate the sines and cosines to exponential, it is possible to write the series using complex exponential: \\[ f(x) = \\sum_{i=-\\infty}^\\infty c_j \\exp \\left( i \\left[\\frac{2 \\pi j x}{L}\\right] \\right) \\] where the sum limit now goes from \\(-\\infty\\) to \\(\\infty\\) . The coefficients \\(c_j\\) s can be obtained by using the orthogonality of the complex exponential \\[\\int_0^L e^{i \\left[\\frac{2 \\pi j}{L}\\right] x} e^{-i \\left[\\frac{2 \\pi j'}{L}\\right] x} dx = L \\delta(j-j')\\] \\[ c_j = \\frac{1}{L} \\int_{0}^L f(x) \\exp \\left( - i \\left[ \\frac{2 \\pi j x}{L} \\right] \\right) \\] Therefore, we can represent the function \\(f(x)\\) as the coefficients of Fourier series \\(\\{ c_j \\}\\) . Given one representation we can find the other and vice versa.","title":"Fourier Series"},{"location":"ch_fouriertransform/#discrete-fourier-transform","text":"In many practical applications, fourier transforms of discretely sampled data points is useful. Discrete fourier transform of a set of n-data points \\(\\{a_0, a_1, a_2, \\dots, a_{n-1}\\}\\) is defined as: Discrete Fourier Transform \\[ A_k = \\sum_{m=0}^{n-1} a_m \\exp{ \\left\\{ - 2 \\pi i \\left[ \\frac{m k}{n} \\right] \\right\\}} \\] Here \\(A_k\\) are the fourier coefficients (n of them). From these fourier coefficients, we can get back the initial data points \\(a_m\\) s through an inverse discrete fourier transform: Inverse Discrete Fourier Transform \\[ a_m = \\frac{1}{n} \\sum_{k=0}^{n-1} A_k \\exp{ \\left\\{ 2 \\pi i \\left[ \\frac{m k}{n} \\right] \\right\\}} \\] It is possible to implement a direct version of this formula in python as python supports complex numbers. For instance the complex number \\(i\\) is implemented in python using 1j . However, as \\(n\\) increases these direct implementations of DFT will take a long time to evaluate as the number of operations go as \\(\\mathcal{O}(n^2)\\) . As such, a more clever algrithm called the fast fourier transform are implemented in software packages that calculate discrete fourier transform. For example, numpy has numpy.fft.fft and numpy.fft.rfft functions that are useful to calculate fourier transforms. Time series sunspot data Implement your own discrete fourier transform dft function and use it to fourier transform the time series sunspot data . To understand the result, notice that if our data is a time series as is the sunspot data (number of sunspots each month), then the fourier transform gives us a measure of the frequency. First, notice that when \\(k=0\\) , the fourier transform \\(A_0\\) is just the average of the data points: \\[ A_0 = \\frac{1}{n} \\sum_{m=0}^{n-1} a_m \\] We can think of this as a wave with zero frequency. Second, when \\(k=1\\) , we start to get the coefficient of the Fourier wave decomposition with frequency \\(f_1 = \\frac{1}{n \\Delta t}\\) , and the frequency increases with increasing \\(k\\) . In general: \\[ f_k = \\frac{k}{n \\Delta t} \\] In the sunspot data \\(\\Delta t = 1\\ {\\rm month}\\) . By plotting the power spectrum \\(p_k = |A_k|^2 = A_k^* A_k\\) of the Fourier coefficients, and finding out the \\(k\\) at which it is maximum, it is possible to find the periodicity of the sunspot data using \\(T= 1/f\\) .","title":"Discrete fourier transform"},{"location":"ch_intro/","text":"Introduction Review of Programming We will mostly make use of the python programming language in this introduction and for much of the course (but not always as we will also look at Mathematica ). Since a basic course in programming is a pre-requisite for this course, some level of familiarity with programming is assumed. The first step is to make sure that you have the proper environment setup on your computer. Make sure that you have python 3 installed; also install the numpy package. One way to make sure that these two packages are installed is to install the Anaconda Python Distribution . Alternatively, for quick running of code on the web, you could make use of Google Colab , which will open a notebook interface in which you can run python code. Google Colab uses a modified versin of Jupyter Notebook ; you can try to install/run jupyter notebook on your computer if you find the notebook interface useful. Alternatively, Once you have the proper programming environment setup, let's begin with the following basic tasks that most programming languages can do - output, loop and condition. Printing Output Input Output import numpy import numpy as np # (1) print ( np . log10 ( 10 ), np . log ( 10 )) # (2) import the numerical library numpy for mathematical operations np.log10(10) calculates the base-10 logarithm whereas np.log(10) calculates the natural logarithm of 10. print function is used to print the two outputs to the screen. 1.0 2.302585092994046 You should expect two numbers as the output: one for log base 10 i.e. \\(\\log_{\\rm 10}\\) and the other for natural logarithm i.e. \\(\\ln(10)\\) . For the above code to run, you may save the code in a file with name such as filename.py and on the command line enter: python filename.py Depending on your installation of python, you may also have to install the additional library used in your code; for example, if you do not have the numpy library installed, you can install using pip install numpy The for loop Let us look at one more example python code to illustrate the use of variables and for loop. Input Output sum of integers from 1 to 100 total = 0 # (1) for i in range ( 1 , 101 ): # (2) total = total + i # (3) print ( total ) # (4) variable total is initially assigned a value of zero note the natural language-like syntax for for loop in python; also, note that range(1, 101) excludes 101 . note that indentation of code is important in python the total variable is printed on the screen once the program exits the for loop after adding 1 to 100. sum of integers from 1 to 100 5050 The if condition Consider the following python code that checks whether an integer is odd or even. Input Output check if an integer is odd or even def check_even ( n ): \"\"\"Checks if the given integer n is even Args: n: integer Returns: True if n is even, False else \"\"\" if ( n % 2 == 0 ): return True return False print ( check_even ( 9 ), check_even ( 10 )) check if an integer is odd or even False True In the code above we have also used def to define a new function. Inside the def function block, we have used three double-quote \"\"\" format for docstring . The while loop The while loop runs as long as the condition given in its syntax is satisfied. The while loop can be used instead of the for loop to get the sum of integers; see example below: Input Output sum of integers from 1 to 100 using while total = 0 i = 0 while ( i <= 100 ): total = total + i i = i + 1 print ( total ) sum of integers from 1 to 100 using while 5050 Fibonacci numbers Write a python code to print out Fibonacci numbers upto a certain value say all the Fibonacci numbers less than 10000. The first two Fibonacci numbers are 1,1 and the rule for Fibonacci sequence is that the next number is obtained by a sum of previous two numbers. Lists and Arrays In-built Lists in Python Input Output list example List1 = [ 1 , 2 , 3 ] List2 = [ \"red\" , \"blue\" , \"green\" ] List3 = [ - 1 , 0 , \"orange\" ] print ( List1 [ 0 ], List2 [ 1 ], List3 [ 2 ]) List1 . append ( 4 ) # (1) print ( List1 ) List1 . pop () # (2) print ( List1 ) Add an element to the list. Remove the last element of the list. list example 1 blue orange [ 1 , 2 , 3 , 4 ] [ 1 , 2 , 3 ] A list can contain different types of elements. As you have seen in the example above, List3 consists of both integers and an string. Elements can also be added or removed from a list i.e. a list can grow or shrink during the execution of a program. Arrays The array module in python supports an object type called Array that can do more mathematical operations than the in-built python lists. However, the numpy module has support for a similar object array with support for more mathematical operations (including vector and matrix operations). Therefore, we will look at the numpy.array object: Input Output simple numpy.array examples import numpy as np # first a simple 1D array arr1 = np . array ([ 1.0 , 2.0 , 3.0 ]) print ( arr1 ) # a simple 2D array arr2 = np . array ([[ 1.0 , 2.0 , 3.0 ], [ 1.5 , 2.5 , 3.5 ]]) print ( arr2 ) # to access the element of an array we can use indexing as follows: print ( arr2 [ 0 , 0 ]) # outputs 1.0 (the first row, first column) print ( arr2 [ 0 , 1 ]) # outputs 2.0 (the first row, second column) print ( arr1 [ 1 ]) # outputs 2.0 (the second element of a 1D array) simple numpy.array examples [[ 1. 2. 3. ] [ 1.5 2.5 3.5 ]] 1.0 2.0 2.0 Now, let us make use of the numpy.array and numpy.sum to calculate the sum of integers from 1 to 100. Input Output numpy.array example to sum integers from 1 to 100 import numpy as np arr3 = np . array ([ i for i in range ( 0 , 101 )]) print ( arr3 ) print ( np . sum ( arr3 )) numpy.array example to sum integers from 1 to 100 array ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ]) 5050 In the example above, instead of arr2 = np.array([i for i in range(0, 101)]) we could have used arr2 = np.array(range(0, 101)) or simply arr2 = range(0, 101) and still obtained the desired result of 5050 . However, the way the syntax is written in the example is more powerful than these substitutes. For example, you can obtain the sum of squares of integers from 1 to 100 \\(\\left(\\sum_{i=1}^{100} i^2\\right)\\) by the following code: arr3 = np . array ([ i ** 2.0 for i in range ( 0 , 101 )]) print ( np . sum ( arr3 )) Numpy arrays as vectors and matrices A numpy array of one dimension can be thought of as a vector, and numpy supports vector operations such as dot product. Input Output numpy array as a vector import numpy as np v1 = np . array ([ 1.0 , - 1.0 , 2.0 ]) v2 = np . array ([ - 1.0 , 1.0 , 2.0 ]) v1dotv2 = v1 . dot ( v2 ) # you could also use np.dot(v1, v2) print ( \"The dot product is: \" , v1dotv2 ) numpy array as a vector The dot product is : 2.0 Initializing a multidimensional array Sometimes it is useful to initialize a multidimensional array -- for example a \\(N\\times N\\) matrix with all entries as zeros. Such an array can be updated later in the code with appropriate values for each element as needed. The numpy.zeros(shape) function can be used to generate arrays of given shape filled with zeros. Input 1 Output 1 np . zeros ( 5 ) array ([ 0. , 0. , 0. , 0. , 0. ]) Multidimensional arrays can be generated by giving the shape -- for example a \\(m \\times n\\) matrix of zeros can be created using np.zeros((m,n)) Input 2 Output 2 np . zeros (( 2 , 2 )) array ([[ 0. , 0. ], [ 0. , 0. ]]) Similar to np.zeros , there is also np.ones that fills the array with ones. Version Control Computer codes (and even documents) may require updating at times. At the early stages of developing a computer code, the frequency of updates may be very high. Even for a matured piece of code, there may be maintenance updates that will require you to update the code time and again. Version control tools help us with this process. They can also be useful if we decide to revert a change at a later time and in case that multiple people are collaborating on the same piece of software or document at once. We will make use of github for version control. The underlying version control software utilized by github is called git . Please take the following github skills course to begin. Introduction to GitHub - Github Skills Documentation The code you write will likely be read by other people that may include friends, collegues, professors, customors and users. Therefore, good documentation of code is very important and perhaps even more so for large projects. Large projects typically also follow a certain style guide so that the code and documentation written by numerous contributors have consistent style. For example, there is PEP 8 Style Guide for Python Code and PEP 257 Docstring Conventions that are generally followed. Another popular style guide for python is the Google Python Style Guide . In this course, we will not be worrying about strictly following a style guide, but it is good to know that these exist and that you can make use of one if necessary.","title":"Introduction"},{"location":"ch_intro/#introduction","text":"","title":"Introduction"},{"location":"ch_intro/#review-of-programming","text":"We will mostly make use of the python programming language in this introduction and for much of the course (but not always as we will also look at Mathematica ). Since a basic course in programming is a pre-requisite for this course, some level of familiarity with programming is assumed. The first step is to make sure that you have the proper environment setup on your computer. Make sure that you have python 3 installed; also install the numpy package. One way to make sure that these two packages are installed is to install the Anaconda Python Distribution . Alternatively, for quick running of code on the web, you could make use of Google Colab , which will open a notebook interface in which you can run python code. Google Colab uses a modified versin of Jupyter Notebook ; you can try to install/run jupyter notebook on your computer if you find the notebook interface useful. Alternatively, Once you have the proper programming environment setup, let's begin with the following basic tasks that most programming languages can do - output, loop and condition.","title":"Review of Programming"},{"location":"ch_intro/#printing-output","text":"Input Output import numpy import numpy as np # (1) print ( np . log10 ( 10 ), np . log ( 10 )) # (2) import the numerical library numpy for mathematical operations np.log10(10) calculates the base-10 logarithm whereas np.log(10) calculates the natural logarithm of 10. print function is used to print the two outputs to the screen. 1.0 2.302585092994046 You should expect two numbers as the output: one for log base 10 i.e. \\(\\log_{\\rm 10}\\) and the other for natural logarithm i.e. \\(\\ln(10)\\) . For the above code to run, you may save the code in a file with name such as filename.py and on the command line enter: python filename.py Depending on your installation of python, you may also have to install the additional library used in your code; for example, if you do not have the numpy library installed, you can install using pip install numpy","title":"Printing Output"},{"location":"ch_intro/#the-for-loop","text":"Let us look at one more example python code to illustrate the use of variables and for loop. Input Output sum of integers from 1 to 100 total = 0 # (1) for i in range ( 1 , 101 ): # (2) total = total + i # (3) print ( total ) # (4) variable total is initially assigned a value of zero note the natural language-like syntax for for loop in python; also, note that range(1, 101) excludes 101 . note that indentation of code is important in python the total variable is printed on the screen once the program exits the for loop after adding 1 to 100. sum of integers from 1 to 100 5050","title":"The for loop"},{"location":"ch_intro/#the-if-condition","text":"Consider the following python code that checks whether an integer is odd or even. Input Output check if an integer is odd or even def check_even ( n ): \"\"\"Checks if the given integer n is even Args: n: integer Returns: True if n is even, False else \"\"\" if ( n % 2 == 0 ): return True return False print ( check_even ( 9 ), check_even ( 10 )) check if an integer is odd or even False True In the code above we have also used def to define a new function. Inside the def function block, we have used three double-quote \"\"\" format for docstring .","title":"The if condition"},{"location":"ch_intro/#the-while-loop","text":"The while loop runs as long as the condition given in its syntax is satisfied. The while loop can be used instead of the for loop to get the sum of integers; see example below: Input Output sum of integers from 1 to 100 using while total = 0 i = 0 while ( i <= 100 ): total = total + i i = i + 1 print ( total ) sum of integers from 1 to 100 using while 5050 Fibonacci numbers Write a python code to print out Fibonacci numbers upto a certain value say all the Fibonacci numbers less than 10000. The first two Fibonacci numbers are 1,1 and the rule for Fibonacci sequence is that the next number is obtained by a sum of previous two numbers.","title":"The while loop"},{"location":"ch_intro/#lists-and-arrays","text":"","title":"Lists and Arrays"},{"location":"ch_intro/#in-built-lists-in-python","text":"Input Output list example List1 = [ 1 , 2 , 3 ] List2 = [ \"red\" , \"blue\" , \"green\" ] List3 = [ - 1 , 0 , \"orange\" ] print ( List1 [ 0 ], List2 [ 1 ], List3 [ 2 ]) List1 . append ( 4 ) # (1) print ( List1 ) List1 . pop () # (2) print ( List1 ) Add an element to the list. Remove the last element of the list. list example 1 blue orange [ 1 , 2 , 3 , 4 ] [ 1 , 2 , 3 ] A list can contain different types of elements. As you have seen in the example above, List3 consists of both integers and an string. Elements can also be added or removed from a list i.e. a list can grow or shrink during the execution of a program.","title":"In-built Lists in Python"},{"location":"ch_intro/#arrays","text":"The array module in python supports an object type called Array that can do more mathematical operations than the in-built python lists. However, the numpy module has support for a similar object array with support for more mathematical operations (including vector and matrix operations). Therefore, we will look at the numpy.array object: Input Output simple numpy.array examples import numpy as np # first a simple 1D array arr1 = np . array ([ 1.0 , 2.0 , 3.0 ]) print ( arr1 ) # a simple 2D array arr2 = np . array ([[ 1.0 , 2.0 , 3.0 ], [ 1.5 , 2.5 , 3.5 ]]) print ( arr2 ) # to access the element of an array we can use indexing as follows: print ( arr2 [ 0 , 0 ]) # outputs 1.0 (the first row, first column) print ( arr2 [ 0 , 1 ]) # outputs 2.0 (the first row, second column) print ( arr1 [ 1 ]) # outputs 2.0 (the second element of a 1D array) simple numpy.array examples [[ 1. 2. 3. ] [ 1.5 2.5 3.5 ]] 1.0 2.0 2.0 Now, let us make use of the numpy.array and numpy.sum to calculate the sum of integers from 1 to 100. Input Output numpy.array example to sum integers from 1 to 100 import numpy as np arr3 = np . array ([ i for i in range ( 0 , 101 )]) print ( arr3 ) print ( np . sum ( arr3 )) numpy.array example to sum integers from 1 to 100 array ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ]) 5050 In the example above, instead of arr2 = np.array([i for i in range(0, 101)]) we could have used arr2 = np.array(range(0, 101)) or simply arr2 = range(0, 101) and still obtained the desired result of 5050 . However, the way the syntax is written in the example is more powerful than these substitutes. For example, you can obtain the sum of squares of integers from 1 to 100 \\(\\left(\\sum_{i=1}^{100} i^2\\right)\\) by the following code: arr3 = np . array ([ i ** 2.0 for i in range ( 0 , 101 )]) print ( np . sum ( arr3 ))","title":"Arrays"},{"location":"ch_intro/#numpy-arrays-as-vectors-and-matrices","text":"A numpy array of one dimension can be thought of as a vector, and numpy supports vector operations such as dot product. Input Output numpy array as a vector import numpy as np v1 = np . array ([ 1.0 , - 1.0 , 2.0 ]) v2 = np . array ([ - 1.0 , 1.0 , 2.0 ]) v1dotv2 = v1 . dot ( v2 ) # you could also use np.dot(v1, v2) print ( \"The dot product is: \" , v1dotv2 ) numpy array as a vector The dot product is : 2.0","title":"Numpy arrays as vectors and matrices"},{"location":"ch_intro/#initializing-a-multidimensional-array","text":"Sometimes it is useful to initialize a multidimensional array -- for example a \\(N\\times N\\) matrix with all entries as zeros. Such an array can be updated later in the code with appropriate values for each element as needed. The numpy.zeros(shape) function can be used to generate arrays of given shape filled with zeros. Input 1 Output 1 np . zeros ( 5 ) array ([ 0. , 0. , 0. , 0. , 0. ]) Multidimensional arrays can be generated by giving the shape -- for example a \\(m \\times n\\) matrix of zeros can be created using np.zeros((m,n)) Input 2 Output 2 np . zeros (( 2 , 2 )) array ([[ 0. , 0. ], [ 0. , 0. ]]) Similar to np.zeros , there is also np.ones that fills the array with ones.","title":"Initializing a multidimensional array"},{"location":"ch_intro/#version-control","text":"Computer codes (and even documents) may require updating at times. At the early stages of developing a computer code, the frequency of updates may be very high. Even for a matured piece of code, there may be maintenance updates that will require you to update the code time and again. Version control tools help us with this process. They can also be useful if we decide to revert a change at a later time and in case that multiple people are collaborating on the same piece of software or document at once. We will make use of github for version control. The underlying version control software utilized by github is called git . Please take the following github skills course to begin. Introduction to GitHub - Github Skills","title":"Version Control"},{"location":"ch_intro/#documentation","text":"The code you write will likely be read by other people that may include friends, collegues, professors, customors and users. Therefore, good documentation of code is very important and perhaps even more so for large projects. Large projects typically also follow a certain style guide so that the code and documentation written by numerous contributors have consistent style. For example, there is PEP 8 Style Guide for Python Code and PEP 257 Docstring Conventions that are generally followed. Another popular style guide for python is the Google Python Style Guide . In this course, we will not be worrying about strictly following a style guide, but it is good to know that these exist and that you can make use of one if necessary.","title":"Documentation"},{"location":"ch_mltools/","text":"Machine Learning Tools Classification using ready-made ML tools Example","title":"Machine Learning Tools"},{"location":"ch_mltools/#machine-learning-tools","text":"","title":"Machine Learning Tools"},{"location":"ch_mltools/#classification-using-ready-made-ml-tools","text":"","title":"Classification using ready-made ML tools"},{"location":"ch_mltools/#example","text":"","title":"Example"},{"location":"ch_montecarlo/","text":"Monte Carlo Methods Random numbers Consider the output of the following code: random module import random random . seed ( 1000 ) print ( random . random (), random . random ()) The output will be two numbers printed on the screen. The random.random() command gives you a random number in the range [0.0, 1.0) . The likelihood of getting a particular value between 0 and 1 is the same. In statistical language, such a likelihood/probability is called a uniform distribution. If you want to get a random number in a different range, say [a, b] , you can either use the result of random . random () and rescale it appropriately, or directly use the function random . uniform ( a , b ) . Use of random . seed () : If you use the same seed number (argument) in calling random . seed ( seed ) before calling random . random () , the output is identical for the same seed . Because the returned random numbers depend on the seed , the number generator used by the random module is called a pseudo- random number generator. Such a generator is useful if you have to reproduce results (e.g. simulation) at a later time. If you do not provide an argument to random.seed or set random.seed(None) , the current system time is used as a proxy to a random seed and you will get different results each time you call random.random() . Estimating area using random numbers We can make use of random numbers to estimate areas. Suppose we want to estimate the area of the unit circle. Area of a unit circle \\[ A = \\pi r ^2 = \\pi (1)^2 = \\pi \\] In this case, we know the answer is \\(\\pi\\) . Therefore, we can frame this exercise as a method to estimate the numerical value of \\(\\pi\\) as well. Consider a unit circle embedded in a square. Now, in each step, we will generate two random numbers \\((x, y)\\) inside the embedding square, and check whether this randomly generated point lies inside of the unit circle or outside. Then an estimate of the area of the unit circle can be made: \\[ A = \\left( \\frac{\\rm points\\ inside\\ the\\ circle}{\\rm total\\ points} \\right) \\times {\\rm area\\ of\\ embedding\\ square}\\] Total Points: 0 Points Inside: 0 Area Estimate: Refresh the page to estimate using a new set of random points. var canvas = document.getElementById('canvas1') var NN = document.getElementById('NP') if (canvas.getContext) { var ctx = canvas.getContext('2d'); } function randomPoint() { x = Math.random()*200+50; y = Math.random()*200+50; if ((x-150)*(x-150)+(y-150)*(y-150)<=10000) { pts = pts + 1; ctx.fillStyle=\"green\"; } else { ctx.fillStyle=\"blue\"; } total = total + 1; ctx.fillRect(x, y, 1, 1); document.getElementById('label1').innerHTML = pts; document.getElementById('label2').innerHTML = total; Area = 4*pts/total document.getElementById('Aest').innerHTML = Area; } function calcpi() { ctx.clearRect(0, 0, 300, 300); ctx.beginPath(); ctx.strokeStyle=\"blue\"; ctx.rect(50, 50, 200, 200); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=\"red\"; ctx.arc(150, 150, 100, 2*Math.PI, false); ctx.stroke(); pts = 0; total = 0; for (let i = 0; i < NN.value; i++) { randomPoint(); ctx.stroke(); } } calcpi(); Python code to estimate \\(\\pi\\) Estimate area of a unit circle def pi_estimate ( total = 1000 ): pts_in = 0 for i in range ( total ): x = random . uniform ( - 1 , 1 ) y = random . uniform ( - 1 , 1 ) if ( x ** 2.0 + y ** 2.0 <= 1.0 ): pts_in = pts_in + 1.0 return 4.0 * pts_in / total print ( pi_estimate ()) Increasing the number of points used through the total argument in the pi_estimate function improves the estimate. If \\(N\\) is the number of points used, the standard error scales as \\(1/\\sqrt{N}\\) . Monte Carlo Integration Markov Chain Monte Carlo (MCMC) Examples","title":"Monte Carlo Methods"},{"location":"ch_montecarlo/#monte-carlo-methods","text":"","title":"Monte Carlo Methods"},{"location":"ch_montecarlo/#random-numbers","text":"Consider the output of the following code: random module import random random . seed ( 1000 ) print ( random . random (), random . random ()) The output will be two numbers printed on the screen. The random.random() command gives you a random number in the range [0.0, 1.0) . The likelihood of getting a particular value between 0 and 1 is the same. In statistical language, such a likelihood/probability is called a uniform distribution. If you want to get a random number in a different range, say [a, b] , you can either use the result of random . random () and rescale it appropriately, or directly use the function random . uniform ( a , b ) . Use of random . seed () : If you use the same seed number (argument) in calling random . seed ( seed ) before calling random . random () , the output is identical for the same seed . Because the returned random numbers depend on the seed , the number generator used by the random module is called a pseudo- random number generator. Such a generator is useful if you have to reproduce results (e.g. simulation) at a later time. If you do not provide an argument to random.seed or set random.seed(None) , the current system time is used as a proxy to a random seed and you will get different results each time you call random.random() .","title":"Random numbers"},{"location":"ch_montecarlo/#estimating-area-using-random-numbers","text":"We can make use of random numbers to estimate areas. Suppose we want to estimate the area of the unit circle. Area of a unit circle \\[ A = \\pi r ^2 = \\pi (1)^2 = \\pi \\] In this case, we know the answer is \\(\\pi\\) . Therefore, we can frame this exercise as a method to estimate the numerical value of \\(\\pi\\) as well. Consider a unit circle embedded in a square. Now, in each step, we will generate two random numbers \\((x, y)\\) inside the embedding square, and check whether this randomly generated point lies inside of the unit circle or outside. Then an estimate of the area of the unit circle can be made: \\[ A = \\left( \\frac{\\rm points\\ inside\\ the\\ circle}{\\rm total\\ points} \\right) \\times {\\rm area\\ of\\ embedding\\ square}\\] Total Points: 0 Points Inside: 0 Area Estimate: Refresh the page to estimate using a new set of random points. var canvas = document.getElementById('canvas1') var NN = document.getElementById('NP') if (canvas.getContext) { var ctx = canvas.getContext('2d'); } function randomPoint() { x = Math.random()*200+50; y = Math.random()*200+50; if ((x-150)*(x-150)+(y-150)*(y-150)<=10000) { pts = pts + 1; ctx.fillStyle=\"green\"; } else { ctx.fillStyle=\"blue\"; } total = total + 1; ctx.fillRect(x, y, 1, 1); document.getElementById('label1').innerHTML = pts; document.getElementById('label2').innerHTML = total; Area = 4*pts/total document.getElementById('Aest').innerHTML = Area; } function calcpi() { ctx.clearRect(0, 0, 300, 300); ctx.beginPath(); ctx.strokeStyle=\"blue\"; ctx.rect(50, 50, 200, 200); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=\"red\"; ctx.arc(150, 150, 100, 2*Math.PI, false); ctx.stroke(); pts = 0; total = 0; for (let i = 0; i < NN.value; i++) { randomPoint(); ctx.stroke(); } } calcpi(); Python code to estimate \\(\\pi\\) Estimate area of a unit circle def pi_estimate ( total = 1000 ): pts_in = 0 for i in range ( total ): x = random . uniform ( - 1 , 1 ) y = random . uniform ( - 1 , 1 ) if ( x ** 2.0 + y ** 2.0 <= 1.0 ): pts_in = pts_in + 1.0 return 4.0 * pts_in / total print ( pi_estimate ()) Increasing the number of points used through the total argument in the pi_estimate function improves the estimate. If \\(N\\) is the number of points used, the standard error scales as \\(1/\\sqrt{N}\\) .","title":"Estimating area using random numbers"},{"location":"ch_montecarlo/#monte-carlo-integration","text":"","title":"Monte Carlo Integration"},{"location":"ch_montecarlo/#markov-chain-monte-carlo-mcmc","text":"","title":"Markov Chain Monte Carlo (MCMC)"},{"location":"ch_montecarlo/#examples","text":"","title":"Examples"},{"location":"ch_numeric/","text":"Numerical Methods for Differentiation First, let us look into some methods for calculating numerical derivatives. Finite Differences Numerical derivatives of a function \\(f(x)\\) at \\(x=x_0\\) can be calculated by the method of finite differences. Recall that the derivative \\(f'(x_0)\\) tells you about the slope of the tangent at \\(x=x_0\\) . Such a slope can be drawn by drawing a line by considering two nearby points on either side of \\(P(x_0, f(x_0))\\) : \\(P_-(x_0-h, f(x_0-h))\\) and \\(P_+(x_0+h, f(x_0+h))\\) where \\(h\\) is small. Therefore, the estimate for the slope and therefore the derivative \\(f'(x_0)\\) becomes: \\[f'(x_0) = \\frac{f(x_0+h)-f(x_0-h)}{x_0+h-(x_0-h)}=\\frac{f(x_0+h)-f(x_0-h)}{2 h}\\] You should convince yourself that as \\(h\\rightarrow 0\\) , your estimate approaches the exact derivative. Sample code and accuracy check Python code for central difference Accuracy check central difference derivative def central_diff_sin ( x , h ): \"\"\"Calculate numerical derivative of sin(x) using central difference Parameters ---------- x : real angle in radians h : real step size in radians \"\"\" import numpy as np return ( np . sin ( x + h ) - np . sin ( x - h )) / ( 2 * h ) x h central_diff_sin(x,h) cos(x) (actual) percent accuracy 0.3 0.04 0.9550818 0.9553365 0.026660 0.3 0.03 0.9551932 0.9553365 0.014999 0.3 0.02 0.9552728 0.9553365 0.006667 0.3 0.01 0.9553206 0.9553365 0.001663 Estimating accuracy In the example above, we knew the correct value of the operation that we were numerically calculating since \\(\\frac{d\\sin(x)}{dx} = \\cos x\\) . However, the actual value of the numerical methods lies when calculating quantities that do not have an easy analytic solution. In such cases, it is useful to be able to have some knowledge of the error in the numerical estimate. We can estimate the error made when numerically calculating derivatives using the central difference method by using Taylor expansion. Leading order error for central difference Proof using Taylor expansion The leading order approximation error is given by \\[\\epsilon = \\frac{|h^2 f'''(x_0)|}{6}\\] The expression shows that the approximation error \\(\\epsilon\\) decreases as \\(h\\) decreases. For our example above with \\(f(x)=\\sin(x)\\) , \\(x_0=0.3\\) and \\(h=0.01\\) : \\[\\epsilon = \\frac{|(0.01)^2 (\\cos{0.1})|}{6} = 0.00001658 = 0.001658\\% \\] which is close to the actual percent accuracy calculated earlier. For functions in which \\(f'''(x_0)\\) cannot be evaluated, the information that \\(\\epsilon\\) scales as \\(h^2\\) is still very useful. \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] we obtain, \\[ \\frac{f(x_0+h)-f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2 f'''(x_0)}{6} + \\dots \\] which is sometimes written as: \\[ f'(x_0) \\approx \\frac{f(x_0+h)-f(x_0-h)}{2h} + \\mathcal{O}(h^2) \\] where \\(\\mathcal{O}(h^2)\\) indicates that the leading order contribution error made by estimation is proportional to \\(h^2\\) . Forward difference numerical derivative Work out a forward difference approach (i.e. use the slope of line made by \\(P_+\\) and \\(P\\) ) to taking numerical derivative and compare it with the central difference method discussed above in terms of accuracy. Sampled function Suppose you have a sampled function i.e. the function values are known (let's say at a regular interval of \\(h\\) ). Which one is a better approach -- central difference or forward difference for calculating numerical derivatives? A finite difference estimate of second derivative A straight-forward apporach to calculate the second derivative at a point, \\(f''(x_0)\\) is to simply use the finite difference derivative (say central difference) on the first derivative: \\[f''(x_0) \\approx \\frac{f'(x_0+h)-f'(x_0-h)}{2 h}\\] However, as we can see in the above formula, each \\(f''(x_0)\\) evaluation requires two evaluations of first derivatives, and if we use central difference method each derivative requires two more evaluations of the function \\(f(x)\\) . Another approach is to make use of the Taylor expansions of \\(f(x_0+h)\\) and \\(f(x_0-h)\\) to obtain a finite difference estimate of the second derivative \\(f''(x_0)\\) as follows: \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] Adding the above two equations: \\[ f(x_0 +h) + f(x_0-h) = 2 f(x_0) + h^2 f''(x_0) + \\frac{h^4 f^{(4)}(x_0)}{12} + \\dots\\] such that: \\[ f''(x_0)\\approx \\frac{f(x_0+h)+f(x_0-h)-2 f(x_0)}{h^2} + \\mathcal{O}(h^2) \\] without having to calculate the first derivative. This same formula is obtained if we estimate the second derivative as the following finite difference of first derivatives: \\[ f''(x_0) \\approx \\frac{f'(x_0+h/2) - f'(x_0-h/2)}{h} \\]","title":"Numerical Derivatives"},{"location":"ch_numeric/#numerical-methods-for-differentiation","text":"First, let us look into some methods for calculating numerical derivatives.","title":"Numerical Methods for Differentiation"},{"location":"ch_numeric/#finite-differences","text":"Numerical derivatives of a function \\(f(x)\\) at \\(x=x_0\\) can be calculated by the method of finite differences. Recall that the derivative \\(f'(x_0)\\) tells you about the slope of the tangent at \\(x=x_0\\) . Such a slope can be drawn by drawing a line by considering two nearby points on either side of \\(P(x_0, f(x_0))\\) : \\(P_-(x_0-h, f(x_0-h))\\) and \\(P_+(x_0+h, f(x_0+h))\\) where \\(h\\) is small. Therefore, the estimate for the slope and therefore the derivative \\(f'(x_0)\\) becomes: \\[f'(x_0) = \\frac{f(x_0+h)-f(x_0-h)}{x_0+h-(x_0-h)}=\\frac{f(x_0+h)-f(x_0-h)}{2 h}\\] You should convince yourself that as \\(h\\rightarrow 0\\) , your estimate approaches the exact derivative.","title":"Finite Differences"},{"location":"ch_numeric/#sample-code-and-accuracy-check","text":"Python code for central difference Accuracy check central difference derivative def central_diff_sin ( x , h ): \"\"\"Calculate numerical derivative of sin(x) using central difference Parameters ---------- x : real angle in radians h : real step size in radians \"\"\" import numpy as np return ( np . sin ( x + h ) - np . sin ( x - h )) / ( 2 * h ) x h central_diff_sin(x,h) cos(x) (actual) percent accuracy 0.3 0.04 0.9550818 0.9553365 0.026660 0.3 0.03 0.9551932 0.9553365 0.014999 0.3 0.02 0.9552728 0.9553365 0.006667 0.3 0.01 0.9553206 0.9553365 0.001663","title":"Sample code and accuracy check"},{"location":"ch_numeric/#estimating-accuracy","text":"In the example above, we knew the correct value of the operation that we were numerically calculating since \\(\\frac{d\\sin(x)}{dx} = \\cos x\\) . However, the actual value of the numerical methods lies when calculating quantities that do not have an easy analytic solution. In such cases, it is useful to be able to have some knowledge of the error in the numerical estimate. We can estimate the error made when numerically calculating derivatives using the central difference method by using Taylor expansion. Leading order error for central difference Proof using Taylor expansion The leading order approximation error is given by \\[\\epsilon = \\frac{|h^2 f'''(x_0)|}{6}\\] The expression shows that the approximation error \\(\\epsilon\\) decreases as \\(h\\) decreases. For our example above with \\(f(x)=\\sin(x)\\) , \\(x_0=0.3\\) and \\(h=0.01\\) : \\[\\epsilon = \\frac{|(0.01)^2 (\\cos{0.1})|}{6} = 0.00001658 = 0.001658\\% \\] which is close to the actual percent accuracy calculated earlier. For functions in which \\(f'''(x_0)\\) cannot be evaluated, the information that \\(\\epsilon\\) scales as \\(h^2\\) is still very useful. \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] we obtain, \\[ \\frac{f(x_0+h)-f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2 f'''(x_0)}{6} + \\dots \\] which is sometimes written as: \\[ f'(x_0) \\approx \\frac{f(x_0+h)-f(x_0-h)}{2h} + \\mathcal{O}(h^2) \\] where \\(\\mathcal{O}(h^2)\\) indicates that the leading order contribution error made by estimation is proportional to \\(h^2\\) . Forward difference numerical derivative Work out a forward difference approach (i.e. use the slope of line made by \\(P_+\\) and \\(P\\) ) to taking numerical derivative and compare it with the central difference method discussed above in terms of accuracy. Sampled function Suppose you have a sampled function i.e. the function values are known (let's say at a regular interval of \\(h\\) ). Which one is a better approach -- central difference or forward difference for calculating numerical derivatives?","title":"Estimating accuracy"},{"location":"ch_numeric/#a-finite-difference-estimate-of-second-derivative","text":"A straight-forward apporach to calculate the second derivative at a point, \\(f''(x_0)\\) is to simply use the finite difference derivative (say central difference) on the first derivative: \\[f''(x_0) \\approx \\frac{f'(x_0+h)-f'(x_0-h)}{2 h}\\] However, as we can see in the above formula, each \\(f''(x_0)\\) evaluation requires two evaluations of first derivatives, and if we use central difference method each derivative requires two more evaluations of the function \\(f(x)\\) . Another approach is to make use of the Taylor expansions of \\(f(x_0+h)\\) and \\(f(x_0-h)\\) to obtain a finite difference estimate of the second derivative \\(f''(x_0)\\) as follows: \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] Adding the above two equations: \\[ f(x_0 +h) + f(x_0-h) = 2 f(x_0) + h^2 f''(x_0) + \\frac{h^4 f^{(4)}(x_0)}{12} + \\dots\\] such that: \\[ f''(x_0)\\approx \\frac{f(x_0+h)+f(x_0-h)-2 f(x_0)}{h^2} + \\mathcal{O}(h^2) \\] without having to calculate the first derivative. This same formula is obtained if we estimate the second derivative as the following finite difference of first derivatives: \\[ f''(x_0) \\approx \\frac{f'(x_0+h/2) - f'(x_0-h/2)}{h} \\]","title":"A finite difference estimate of second derivative"},{"location":"ch_numericint/","text":"Numerical Methods for Integration Numerical integrations are commonplace in scientific modeling and simulations. If several integrations have to be calculated, not only accuracy and precision but the speed at which those can be obtained becomes important. We will attempt to understand all three concepts (accuracy, precision and the speed of calculation) in the context of some methods of numerical integrations given below. Working with one dimensional integrals, our goal will be to approximate the definite integral: \\[ I(a, b) = \\int_a^b f(x)\\ dx. \\] Trapezoid rule In the trapezoid rule, the integral is approximated by adding the areas of many trapezoids. The interval \\([a,b]\\) is divided into \\(N\\) sections so that the sum of the areas of the \\(N\\) trapezoids provide an estimate for the integral \\(I(a,b)\\) . \\[ I (a,b) \\approx \\sum_{i=1}^{N} A_i \\] where the distance between the parallel sides of the \\(i\\) th trapezoid is \\(h = (b-a)/N\\) and the area of the \\(i\\) th trapezoid is \\[ A_i = \\frac{1}{2} h \\left[f(a+(i-1)h) + f(a+i h)\\right] \\] Each area evaluation \\(A_i\\) requires 2 function \\(f(x)\\) evaluations; so, it appears as if the total cost of the integral estimate is \\(2N\\) evaluations. However, it should be clear that some function evaluations are used twice as two adjacent trapezoids share a side. Therefore, it is better to write the formula in the following form: \\[ \\begin{align}I(a,b) &\\approx \\sum_{i=1}^N \\frac{h}{2}\\left[f(a+(i-1)h) + f(a+i h)\\right] \\\\ &=\\frac{h}{2} \\left[ f(a) + 2 f(a+h) + 2 f(a+2h) + \\dots + f(b) \\right] \\\\ &=\\frac{h}{2}\\left[f(a)+f(b)\\right] + h \\sum_{i=1}^{N-1} f(a+ih) \\end{align}\\] Estimation of Error The leading order error is given by the Euler-Maclaurin formula for the trapezoidal rule: \\[ \\epsilon = \\frac{1}{12} h^2 \\left[ f'(a)-f'(b)\\right].\\] Proofs can be found in textbooks; for example see Chapter 5 of Computational Physics by Mark Newman for a proof. The use of the formula given above for the leading order error requires that we have the knowledge of the first derivative of the function. In the case that we have reliable estimates of \\(f'(a)\\) and \\(f'(b)\\) , we can choose \\(N\\) and therefore \\(h\\) such that we get the desired leading order error \\(\\epsilon\\) . In the adaptive method described next, one increases the number of slices \\(N\\) used in the integration until a desired error level is attained. The error is also estimated based on two consecutive integral estimates. Adaptive Integration We will discuss adaptive integration for the trapezoidal rule, but similar adaptive methods can be derived and used for other rules of integration. Our goal is to get a numerical estimate of the true value of the integral: \\[ I = \\int_{a}^{b} f(x) dx \\] In the first step choose \\(N_1\\) slices, so that \\(h_1 = (b-a)/N_1\\) . From the knowledge that the leading order error is of \\(\\mathcal{O}(h^2)\\) : \\[ I = I_1 + c h_1^2\\] In the second step choose \\(N_2 = 2 N_1\\) slices i.e. double the number of trapezoids used in the integration sum. Then, \\(h_2 = h_1/2\\) and \\[ I = I_2 + c h_2^2 \\] Since we can get \\(I_1\\) and \\(I_2\\) from our code, let us look at their difference and see if that can be used as an estimate of the error made in our numerical estimation of integral. \\[I_2 - I_1 = c h_1^2 - c h_2^2 = 3\\ c h_2^2\\] such that the error of integral estimate \\(I_2\\) can be obtained using: \\[\\epsilon_2 = c h_2^2 = \\frac{1}{3} \\left(I_2 - I_1\\right) \\] In the adaptive integration method, we repeat the process of increasing the number of slices in each step \\(i\\) ; as such the above formula for the error in each step can be generalized to: \\[\\epsilon_i = c h_i^2 = \\frac{1}{3} \\left(I_i - I_{i-1}\\right) \\] The goal in the adaptive integration method is to continue increasing the number of slices until \\(|\\epsilon_i|\\) is less than a pre-defined error tolerance threshold \\(\\delta\\) . Implementation of adaptive integration method for trapezoidal rule In the \\(i-\\) th step, the area estimated using the trapezoidal rule is: \\[ I_i = h_i \\left[ \\frac{1}{2} f(a) + \\frac{1}{2} f(b) + \\sum_{k=1}^{N_i-1} f(a + k h_i) \\right] \\] The summation term above can be split into odd and even parts as follows: \\[ \\begin{align} I_i &= h_i \\left[ \\frac{1}{2} f(a) + \\frac{1}{2} f(b)+ \\sum_{even\\ k}^{2\\ to \\ N_i-2} f(a + k h_i) + \\sum_{odd\\ k}^{1\\ to \\ N_i-1} f(a+k h_i) \\right] \\\\ &= \\frac{h_{i-1}}{2} \\left[\\frac{1}{2} f(a) + \\frac{1}{2} f(b) + \\sum_{k=1}^{N_{i-1}-1} f(a+k h_{i-1}) \\right] + h_i \\sum_{k\\ odd} f(a+ k h_i) \\\\ &= \\frac{1}{2} I_{i-1} + h_i \\sum_{k\\ odd} f(a+ k h_i) \\end{align}\\] That is in each step we only have to evaluate the new \\(N_i/2\\) points and can reuse the previously evaluated points. Implement a code for adaptive integration Use the formula derived above to implement a code that performs the following integration using adaptive integration method for trapezoidal rule with a pre-defined error \\(\\delta\\) : \\[ I = 2 \\int_{-1}^{1} \\sqrt{1- x^2} \\] This integral should result in \\(\\pi\\) as it gives us the area of a unit circle. Check that you can get better (higher precision) estimates of \\(\\pi\\) by decreasing the pre-defined error. Python code Fortran code import numpy as np a = - 1 b = 1 N = 5 delta = 0.000001 eps = 2 * delta def f ( x ): return 2.0 * np . sqrt ( 1 - x * x ) h = ( b - a ) / N I0 = h * ( 0.5 * ( f ( a ) + f ( b )) + np . sum ( np . array ([ f ( a + k * h ) for k in range ( 1 , N - 1 )]))) while ( eps > delta ): N = N * 2 h = h / 2.0 I = 0.5 * I0 + h * np . sum ( np . array ([ f ( a + k * h ) for k in range ( 1 , N - 1 , 2 )])) eps = ( I - I0 ) / 3.0 I0 = I print ( I ) program adapint implicit none integer :: N , k real :: a , b , delta , eps , h , I0 , I real :: func external func real , allocatable :: array1 (:) a = - 1 b = 1 N = 5 delta = 0.000001 eps = 2 * delta h = ( b - a ) / N allocate ( array1 ( N )) do k = 1 , N - 1 array1 ( k ) = func ( a + k * h ) end do I0 = h * ( 0.5 * ( func ( a ) + func ( b )) + sum ( array1 )) deallocate ( array1 ) do while ( eps > delta ) N = N * 2 h = h / 2 allocate ( array1 ( N )) do k = 1 , N - 1 , 2 array1 ( k ) = func ( a + k * h ) end do I = 0.5 * I0 + h * sum ( array1 ) deallocate ( array1 ) eps = ( I - I0 ) / 3.0 I0 = I end do print * , I end program adapint real function func ( x ) implicit none real , intent ( in ) :: x func = 2.0 * sqrt ( 1 - x * x ) end function func","title":"Numerical Integration"},{"location":"ch_numericint/#numerical-methods-for-integration","text":"Numerical integrations are commonplace in scientific modeling and simulations. If several integrations have to be calculated, not only accuracy and precision but the speed at which those can be obtained becomes important. We will attempt to understand all three concepts (accuracy, precision and the speed of calculation) in the context of some methods of numerical integrations given below. Working with one dimensional integrals, our goal will be to approximate the definite integral: \\[ I(a, b) = \\int_a^b f(x)\\ dx. \\]","title":"Numerical Methods for Integration"},{"location":"ch_numericint/#trapezoid-rule","text":"In the trapezoid rule, the integral is approximated by adding the areas of many trapezoids. The interval \\([a,b]\\) is divided into \\(N\\) sections so that the sum of the areas of the \\(N\\) trapezoids provide an estimate for the integral \\(I(a,b)\\) . \\[ I (a,b) \\approx \\sum_{i=1}^{N} A_i \\] where the distance between the parallel sides of the \\(i\\) th trapezoid is \\(h = (b-a)/N\\) and the area of the \\(i\\) th trapezoid is \\[ A_i = \\frac{1}{2} h \\left[f(a+(i-1)h) + f(a+i h)\\right] \\] Each area evaluation \\(A_i\\) requires 2 function \\(f(x)\\) evaluations; so, it appears as if the total cost of the integral estimate is \\(2N\\) evaluations. However, it should be clear that some function evaluations are used twice as two adjacent trapezoids share a side. Therefore, it is better to write the formula in the following form: \\[ \\begin{align}I(a,b) &\\approx \\sum_{i=1}^N \\frac{h}{2}\\left[f(a+(i-1)h) + f(a+i h)\\right] \\\\ &=\\frac{h}{2} \\left[ f(a) + 2 f(a+h) + 2 f(a+2h) + \\dots + f(b) \\right] \\\\ &=\\frac{h}{2}\\left[f(a)+f(b)\\right] + h \\sum_{i=1}^{N-1} f(a+ih) \\end{align}\\]","title":"Trapezoid rule"},{"location":"ch_numericint/#estimation-of-error","text":"The leading order error is given by the Euler-Maclaurin formula for the trapezoidal rule: \\[ \\epsilon = \\frac{1}{12} h^2 \\left[ f'(a)-f'(b)\\right].\\] Proofs can be found in textbooks; for example see Chapter 5 of Computational Physics by Mark Newman for a proof. The use of the formula given above for the leading order error requires that we have the knowledge of the first derivative of the function. In the case that we have reliable estimates of \\(f'(a)\\) and \\(f'(b)\\) , we can choose \\(N\\) and therefore \\(h\\) such that we get the desired leading order error \\(\\epsilon\\) . In the adaptive method described next, one increases the number of slices \\(N\\) used in the integration until a desired error level is attained. The error is also estimated based on two consecutive integral estimates.","title":"Estimation of Error"},{"location":"ch_numericint/#adaptive-integration","text":"We will discuss adaptive integration for the trapezoidal rule, but similar adaptive methods can be derived and used for other rules of integration. Our goal is to get a numerical estimate of the true value of the integral: \\[ I = \\int_{a}^{b} f(x) dx \\] In the first step choose \\(N_1\\) slices, so that \\(h_1 = (b-a)/N_1\\) . From the knowledge that the leading order error is of \\(\\mathcal{O}(h^2)\\) : \\[ I = I_1 + c h_1^2\\] In the second step choose \\(N_2 = 2 N_1\\) slices i.e. double the number of trapezoids used in the integration sum. Then, \\(h_2 = h_1/2\\) and \\[ I = I_2 + c h_2^2 \\] Since we can get \\(I_1\\) and \\(I_2\\) from our code, let us look at their difference and see if that can be used as an estimate of the error made in our numerical estimation of integral. \\[I_2 - I_1 = c h_1^2 - c h_2^2 = 3\\ c h_2^2\\] such that the error of integral estimate \\(I_2\\) can be obtained using: \\[\\epsilon_2 = c h_2^2 = \\frac{1}{3} \\left(I_2 - I_1\\right) \\] In the adaptive integration method, we repeat the process of increasing the number of slices in each step \\(i\\) ; as such the above formula for the error in each step can be generalized to: \\[\\epsilon_i = c h_i^2 = \\frac{1}{3} \\left(I_i - I_{i-1}\\right) \\] The goal in the adaptive integration method is to continue increasing the number of slices until \\(|\\epsilon_i|\\) is less than a pre-defined error tolerance threshold \\(\\delta\\) .","title":"Adaptive Integration"},{"location":"ch_numericint/#implementation-of-adaptive-integration-method-for-trapezoidal-rule","text":"In the \\(i-\\) th step, the area estimated using the trapezoidal rule is: \\[ I_i = h_i \\left[ \\frac{1}{2} f(a) + \\frac{1}{2} f(b) + \\sum_{k=1}^{N_i-1} f(a + k h_i) \\right] \\] The summation term above can be split into odd and even parts as follows: \\[ \\begin{align} I_i &= h_i \\left[ \\frac{1}{2} f(a) + \\frac{1}{2} f(b)+ \\sum_{even\\ k}^{2\\ to \\ N_i-2} f(a + k h_i) + \\sum_{odd\\ k}^{1\\ to \\ N_i-1} f(a+k h_i) \\right] \\\\ &= \\frac{h_{i-1}}{2} \\left[\\frac{1}{2} f(a) + \\frac{1}{2} f(b) + \\sum_{k=1}^{N_{i-1}-1} f(a+k h_{i-1}) \\right] + h_i \\sum_{k\\ odd} f(a+ k h_i) \\\\ &= \\frac{1}{2} I_{i-1} + h_i \\sum_{k\\ odd} f(a+ k h_i) \\end{align}\\] That is in each step we only have to evaluate the new \\(N_i/2\\) points and can reuse the previously evaluated points. Implement a code for adaptive integration Use the formula derived above to implement a code that performs the following integration using adaptive integration method for trapezoidal rule with a pre-defined error \\(\\delta\\) : \\[ I = 2 \\int_{-1}^{1} \\sqrt{1- x^2} \\] This integral should result in \\(\\pi\\) as it gives us the area of a unit circle. Check that you can get better (higher precision) estimates of \\(\\pi\\) by decreasing the pre-defined error. Python code Fortran code import numpy as np a = - 1 b = 1 N = 5 delta = 0.000001 eps = 2 * delta def f ( x ): return 2.0 * np . sqrt ( 1 - x * x ) h = ( b - a ) / N I0 = h * ( 0.5 * ( f ( a ) + f ( b )) + np . sum ( np . array ([ f ( a + k * h ) for k in range ( 1 , N - 1 )]))) while ( eps > delta ): N = N * 2 h = h / 2.0 I = 0.5 * I0 + h * np . sum ( np . array ([ f ( a + k * h ) for k in range ( 1 , N - 1 , 2 )])) eps = ( I - I0 ) / 3.0 I0 = I print ( I ) program adapint implicit none integer :: N , k real :: a , b , delta , eps , h , I0 , I real :: func external func real , allocatable :: array1 (:) a = - 1 b = 1 N = 5 delta = 0.000001 eps = 2 * delta h = ( b - a ) / N allocate ( array1 ( N )) do k = 1 , N - 1 array1 ( k ) = func ( a + k * h ) end do I0 = h * ( 0.5 * ( func ( a ) + func ( b )) + sum ( array1 )) deallocate ( array1 ) do while ( eps > delta ) N = N * 2 h = h / 2 allocate ( array1 ( N )) do k = 1 , N - 1 , 2 array1 ( k ) = func ( a + k * h ) end do I = 0.5 * I0 + h * sum ( array1 ) deallocate ( array1 ) eps = ( I - I0 ) / 3.0 I0 = I end do print * , I end program adapint real function func ( x ) implicit none real , intent ( in ) :: x func = 2.0 * sqrt ( 1 - x * x ) end function func","title":"Implementation of adaptive integration method for trapezoidal rule"},{"location":"ch_symbolic/","text":"Symbolic and Plotting Tools We will consider symbolic math using Mathematica . Alternatives to Mathematica for symbolic mathematics include Maple , symbolic toolbox for Matlab , and the open source python package sympy . Symbolic Math using Mathematica Mathematica is a popular tool for symbolic math, and is useful for many mathematical tasks such as calculating derivatives and integrals. SUNY Plattsburgh students can install Mathematica on their personal computer. See instructions here . Performing mathematical calculations in Mathematica Try typing D[x^2, x] and pressing Shift + Enter to evaluate the cell: Input Output D [ x ^ 2 , x ] 2 x The command D[x^2, x] calculates the derivative of \\(x^2\\) with respect to \\(x\\) . To calculate an integral, use the Integrate command as: Input Output Integrate [ 2 x , x ] x ^ 2 Mathematica can perform many popular integrals that show up in various topics of physics and mathematics. For example: Consider the Gaussian (normal) distribution with one standard deviation ( \\(\\sigma=1\\) ) and zero mean \\((\\mu=0)\\) : \\[ \\mathcal{N}(x) = \\frac{1}{\\sqrt{2 \\pi}} e^{-{x^2}/{2}} \\] Suppose we want to find the integral of this function from \\(-\\infty\\) to \\(\\infty\\) . Such a definite integral will result in the area under the curve between the limits. Following the same syntax as above, using Sqrt[2 Pi] for \\(\\sqrt{2 \\pi}\\) and using Exp[-x^2] for \\(e^{-x^2}\\) , attempt to calculate the definite integral: \\[ \\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , - Infinity , Infinity }] 1 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx =1\\] The factor of \\(1/\\sqrt{2 \\pi}\\) is used to normalize the distribution \\(P(x)\\) so that it can be used as a probability density function (pdf). The integral of a pdf over all possible values should result in one. Now calculate another definite integral of the same integrand but taking the limits from \\(-1\\) to \\(1\\) i.e. calculate the definite integral: \\[ \\frac{1}{\\sqrt{2\\pi}}\\int_{-1}^{1} e^{-x^2/2} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }] Erf [ 1 / Sqrt [ 2 ]] where Erf is the error function . A numerical output in mathematica can be forced by either using N[] or //N as follows: Input Output N [ Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }]] 0.682689 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-1}^1 e^{-x^2/2} dx = {\\rm Erf}\\left[\\frac{1}{\\sqrt{2}}\\right] = 0.682689\\] Using Mathematica now you should be able to obtain the following results: \\[ \\int_{-1}^1 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.682689 \\] \\[ \\int_{-2}^2 \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx = 0.9545 \\] \\[ \\int_{-3}^3 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.9973 \\] Next we will learn some plotting syntax in Mathematica and use them to plot the integrand used above \\(\\mathcal{N}(x)=e^{-x^2/2}/\\sqrt{2 \\pi}\\) to better understand the normal probability density function. Plotting in Mathematica Input Output Plot [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -5 , 5 }, AxesLabel -> { \"x\" , \"N(x)\" }, PlotLabel -> \"Gaussian Distribution\" ] Plotting in Matplotlib matplotlib is a widely used python plotting library. It can be used in google colab , but you may need to install it ( see instructions ) if you have not already installed matplotlib on your computer. The plot of the normal distribution \\(\\mathcal{N}(x)\\) can be made in matplotlib using the following code: Input Output Making plot using matplotlib import matplotlib.pyplot as plt # (1) import numpy as np # (2) x = np . arange ( - 5 , 5 , 0.01 ) # (3) y = np . exp ( - x * x / 2 ) / np . sqrt ( 2 * np . pi ) # (4) plt . plot ( x , y ) # (5) plt . xlabel ( \"$x$\" ) # (6) plt . ylabel ( \"$\\mathcal {N} (x)$\" ) # (7) plt . title ( \"Gaussian Distribution\" ) # (8) plt . show () # (9) import the pyplot plotting interface from matplotlib library as plt import the numerical python library numpy as np for various array and mathematical functions create an array from -5 to 5 in increments of 0.01; i.e. \\(\\frac{5-(-5)}{0.01}=1000\\) numbers in total. The number of items in the array x can be checked either using len(x) or using np.size(x) generate a numpy array for \\(y=\\mathcal{N}(x)\\) make the plot using two arrays x and y add label on the x axis; the dollar signs means we use LaTex syntax for mathematical typesetting. add label on the y axis add plot title plt.show() may or may not be needed depending on the backend used for plotting; e.g. not needed in notebook interfaces such as jupyter/google colab. We can also plot vector fields using matplotlib . Let us plot the electric field due to a couple of simple charge configurations. Here we will use the streamplot function. Plotting a vector field First think about what you need to do to make such a field plot given that you have a function in matplotlib that directly generates a field plot if you provide it with vector field values in a grid. In 2D you will need to provide the \\(x-\\) component, \\(E_x\\) and the \\(y-\\) component, \\(E_y\\) of the electric field vector at each point. Recall: \\[ \\vec{E}(x,y) = \\frac{k q}{r^2} \\hat{r} = \\frac{k q}{r^3} \\left( x \\hat{i} + y \\hat{j}\\right)\\] is the electric field at a point \\((x,y)\\) due to a charge \\(q\\) at the origin, where \\(r=\\sqrt{x^2+y^2}\\) . Similarly, if the point charge is located at \\((x_0, y_0)\\) rather than the origin: \\[ \\vec{E}(x,y) = \\frac{k q}{r^3} \\left[ (x-x_0)\\hat{i}+(y-y_0)\\hat{j}\\right] \\] where, \\(r = \\sqrt{(x-x_0)^2 + (y-y_0)^2}\\) . Next, we need to understand the arguments of the streamplot function. In the documentation it is mentioned that at least four arguments are required: matplotlib.pyplot.streamplot(x, y, u, v) where x and y can be 1D arrays that form the grid of the vector plot, but u and v must be 2D arrays (like a matrix) providing the \\(x\\) and \\(y\\) components of the vector field at each point. Let us first brainstorm one of the ways to obtain a vector lines plot using streamplot due to a unit positive charge at the origin. For that we will use a mix of programming and natural language without worrying about the syntax, but focusing on the algorithm; we may call this a pseudocode. pseudocode q = 1 k = 1 xlist, ylist = -5 to 5 with 0.1 stepsize Ex, Ey = 100x100 arrays (matrices) with all elements as zeros i = 0 for x in xlist: j = 0 for y in ylist: rcubed = sqrt(x*x+y*y)**3.0 Ex[j,i] = k * q * x / rcubed Ey[j,i] = k * q * y / rcubed j = j + 1 i = i + 1 streamplot(x, y, Ex, Ey) We used Ex[j,i] rather than Ex[i,j] because streamplot requires that these matrices have \"the number of rows and columns match the length of y and x, respectively.\" Now, let's convert the pseudocode to a python code. Python Code Output Electric field lines due to a charge at origin import matplotlib.pyplot as plt import numpy as np q = 1 k = 1 xlist = np . arange ( - 5 , 5 , 0.5 ) ylist = np . arange ( - 5 , 5 , 0.5 ) Ex = np . empty (( len ( ylist ), len ( xlist ))) Ey = np . empty (( len ( ylist ), len ( xlist ))) i = 0 for x in xlist : j = 0 for y in ylist : rcubed = np . sqrt ( x * x + y * y ) ** 3.0 Ex [ j , i ] = k * q * x / rcubed Ey [ j , i ] = k * q * y / rcubed j = j + 1 i = i + 1 plt . streamplot ( xlist , ylist , Ex , Ey , linewidth = 1 , density = 2 , arrowstyle = \"->\" ) Notice that you can specify the linewidth , the density and the arrowstyle in the streamplot function as in the example above, but these are optional arguments. Assignment: Implement a streamplot plot for the electric field lines due to two point charges separated by a distance; for example, one charge is at \\((1,0)\\) and the other is at \\((-1, 0)\\) .","title":"Symbolic and Plotting Tools"},{"location":"ch_symbolic/#symbolic-and-plotting-tools","text":"We will consider symbolic math using Mathematica . Alternatives to Mathematica for symbolic mathematics include Maple , symbolic toolbox for Matlab , and the open source python package sympy .","title":"Symbolic and Plotting Tools"},{"location":"ch_symbolic/#symbolic-math-using-mathematica","text":"Mathematica is a popular tool for symbolic math, and is useful for many mathematical tasks such as calculating derivatives and integrals. SUNY Plattsburgh students can install Mathematica on their personal computer. See instructions here .","title":"Symbolic Math using Mathematica"},{"location":"ch_symbolic/#performing-mathematical-calculations-in-mathematica","text":"Try typing D[x^2, x] and pressing Shift + Enter to evaluate the cell: Input Output D [ x ^ 2 , x ] 2 x The command D[x^2, x] calculates the derivative of \\(x^2\\) with respect to \\(x\\) . To calculate an integral, use the Integrate command as: Input Output Integrate [ 2 x , x ] x ^ 2 Mathematica can perform many popular integrals that show up in various topics of physics and mathematics. For example: Consider the Gaussian (normal) distribution with one standard deviation ( \\(\\sigma=1\\) ) and zero mean \\((\\mu=0)\\) : \\[ \\mathcal{N}(x) = \\frac{1}{\\sqrt{2 \\pi}} e^{-{x^2}/{2}} \\] Suppose we want to find the integral of this function from \\(-\\infty\\) to \\(\\infty\\) . Such a definite integral will result in the area under the curve between the limits. Following the same syntax as above, using Sqrt[2 Pi] for \\(\\sqrt{2 \\pi}\\) and using Exp[-x^2] for \\(e^{-x^2}\\) , attempt to calculate the definite integral: \\[ \\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , - Infinity , Infinity }] 1 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx =1\\] The factor of \\(1/\\sqrt{2 \\pi}\\) is used to normalize the distribution \\(P(x)\\) so that it can be used as a probability density function (pdf). The integral of a pdf over all possible values should result in one. Now calculate another definite integral of the same integrand but taking the limits from \\(-1\\) to \\(1\\) i.e. calculate the definite integral: \\[ \\frac{1}{\\sqrt{2\\pi}}\\int_{-1}^{1} e^{-x^2/2} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }] Erf [ 1 / Sqrt [ 2 ]] where Erf is the error function . A numerical output in mathematica can be forced by either using N[] or //N as follows: Input Output N [ Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }]] 0.682689 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-1}^1 e^{-x^2/2} dx = {\\rm Erf}\\left[\\frac{1}{\\sqrt{2}}\\right] = 0.682689\\] Using Mathematica now you should be able to obtain the following results: \\[ \\int_{-1}^1 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.682689 \\] \\[ \\int_{-2}^2 \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx = 0.9545 \\] \\[ \\int_{-3}^3 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.9973 \\] Next we will learn some plotting syntax in Mathematica and use them to plot the integrand used above \\(\\mathcal{N}(x)=e^{-x^2/2}/\\sqrt{2 \\pi}\\) to better understand the normal probability density function.","title":"Performing mathematical calculations in Mathematica"},{"location":"ch_symbolic/#plotting-in-mathematica","text":"Input Output Plot [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -5 , 5 }, AxesLabel -> { \"x\" , \"N(x)\" }, PlotLabel -> \"Gaussian Distribution\" ]","title":"Plotting in Mathematica"},{"location":"ch_symbolic/#plotting-in-matplotlib","text":"matplotlib is a widely used python plotting library. It can be used in google colab , but you may need to install it ( see instructions ) if you have not already installed matplotlib on your computer. The plot of the normal distribution \\(\\mathcal{N}(x)\\) can be made in matplotlib using the following code: Input Output Making plot using matplotlib import matplotlib.pyplot as plt # (1) import numpy as np # (2) x = np . arange ( - 5 , 5 , 0.01 ) # (3) y = np . exp ( - x * x / 2 ) / np . sqrt ( 2 * np . pi ) # (4) plt . plot ( x , y ) # (5) plt . xlabel ( \"$x$\" ) # (6) plt . ylabel ( \"$\\mathcal {N} (x)$\" ) # (7) plt . title ( \"Gaussian Distribution\" ) # (8) plt . show () # (9) import the pyplot plotting interface from matplotlib library as plt import the numerical python library numpy as np for various array and mathematical functions create an array from -5 to 5 in increments of 0.01; i.e. \\(\\frac{5-(-5)}{0.01}=1000\\) numbers in total. The number of items in the array x can be checked either using len(x) or using np.size(x) generate a numpy array for \\(y=\\mathcal{N}(x)\\) make the plot using two arrays x and y add label on the x axis; the dollar signs means we use LaTex syntax for mathematical typesetting. add label on the y axis add plot title plt.show() may or may not be needed depending on the backend used for plotting; e.g. not needed in notebook interfaces such as jupyter/google colab. We can also plot vector fields using matplotlib . Let us plot the electric field due to a couple of simple charge configurations. Here we will use the streamplot function. Plotting a vector field First think about what you need to do to make such a field plot given that you have a function in matplotlib that directly generates a field plot if you provide it with vector field values in a grid. In 2D you will need to provide the \\(x-\\) component, \\(E_x\\) and the \\(y-\\) component, \\(E_y\\) of the electric field vector at each point. Recall: \\[ \\vec{E}(x,y) = \\frac{k q}{r^2} \\hat{r} = \\frac{k q}{r^3} \\left( x \\hat{i} + y \\hat{j}\\right)\\] is the electric field at a point \\((x,y)\\) due to a charge \\(q\\) at the origin, where \\(r=\\sqrt{x^2+y^2}\\) . Similarly, if the point charge is located at \\((x_0, y_0)\\) rather than the origin: \\[ \\vec{E}(x,y) = \\frac{k q}{r^3} \\left[ (x-x_0)\\hat{i}+(y-y_0)\\hat{j}\\right] \\] where, \\(r = \\sqrt{(x-x_0)^2 + (y-y_0)^2}\\) . Next, we need to understand the arguments of the streamplot function. In the documentation it is mentioned that at least four arguments are required: matplotlib.pyplot.streamplot(x, y, u, v) where x and y can be 1D arrays that form the grid of the vector plot, but u and v must be 2D arrays (like a matrix) providing the \\(x\\) and \\(y\\) components of the vector field at each point. Let us first brainstorm one of the ways to obtain a vector lines plot using streamplot due to a unit positive charge at the origin. For that we will use a mix of programming and natural language without worrying about the syntax, but focusing on the algorithm; we may call this a pseudocode. pseudocode q = 1 k = 1 xlist, ylist = -5 to 5 with 0.1 stepsize Ex, Ey = 100x100 arrays (matrices) with all elements as zeros i = 0 for x in xlist: j = 0 for y in ylist: rcubed = sqrt(x*x+y*y)**3.0 Ex[j,i] = k * q * x / rcubed Ey[j,i] = k * q * y / rcubed j = j + 1 i = i + 1 streamplot(x, y, Ex, Ey) We used Ex[j,i] rather than Ex[i,j] because streamplot requires that these matrices have \"the number of rows and columns match the length of y and x, respectively.\" Now, let's convert the pseudocode to a python code. Python Code Output Electric field lines due to a charge at origin import matplotlib.pyplot as plt import numpy as np q = 1 k = 1 xlist = np . arange ( - 5 , 5 , 0.5 ) ylist = np . arange ( - 5 , 5 , 0.5 ) Ex = np . empty (( len ( ylist ), len ( xlist ))) Ey = np . empty (( len ( ylist ), len ( xlist ))) i = 0 for x in xlist : j = 0 for y in ylist : rcubed = np . sqrt ( x * x + y * y ) ** 3.0 Ex [ j , i ] = k * q * x / rcubed Ey [ j , i ] = k * q * y / rcubed j = j + 1 i = i + 1 plt . streamplot ( xlist , ylist , Ex , Ey , linewidth = 1 , density = 2 , arrowstyle = \"->\" ) Notice that you can specify the linewidth , the density and the arrowstyle in the streamplot function as in the example above, but these are optional arguments. Assignment: Implement a streamplot plot for the electric field lines due to two point charges separated by a distance; for example, one charge is at \\((1,0)\\) and the other is at \\((-1, 0)\\) .","title":"Plotting in Matplotlib"},{"location":"references/","text":"Resources for further reading and reference Books Numerical Methods in Physics with Python by Alex Gezerlis Computational Physics by Mark Newman Numerical Computing with MATLAB by Cleve Moler Tools used to prepare materials and write these notes Markdown Mkdocs Mkdocs material Python Numpy Mathematica Github and github pages Linux Jupyter notebook HTML and Javascript Other useful references Creating Interactive Web Simulations Using HTML5 and JavaScript by Daniel V. Schroeder The Markov-chain Monte Carlo Interactive Gallery by Chi Feng","title":"Resources for further reading and reference"},{"location":"references/#resources-for-further-reading-and-reference","text":"","title":"Resources for further reading and reference"},{"location":"references/#books","text":"Numerical Methods in Physics with Python by Alex Gezerlis Computational Physics by Mark Newman Numerical Computing with MATLAB by Cleve Moler","title":"Books"},{"location":"references/#tools-used-to-prepare-materials-and-write-these-notes","text":"Markdown Mkdocs Mkdocs material Python Numpy Mathematica Github and github pages Linux Jupyter notebook HTML and Javascript","title":"Tools used to prepare materials and write these notes"},{"location":"references/#other-useful-references","text":"Creating Interactive Web Simulations Using HTML5 and JavaScript by Daniel V. Schroeder The Markov-chain Monte Carlo Interactive Gallery by Chi Feng","title":"Other useful references"}]}
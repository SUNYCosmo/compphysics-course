{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHY 315 Introduction to Computational Methods in Physics Course Description An introduction to computational and numerical methods in physics. Includes an introduction to version control, documentation, collaborative code writing, and creating scientific quality plots. Numerical methods for differentiation, integration, curve fitting and optimization. Introduction to random variables and Monte Carlo methods. Examples are taken from problems in physics which cannot be solved using analytic methods only. Course Topic Outline Introduction (Programming, Version Control and Documentation) Symbolic Tools and Plotting Numerical Methods for Differentiation","title":"Home"},{"location":"#phy-315-introduction-to-computational-methods-in-physics","text":"","title":"PHY 315 Introduction to Computational Methods in Physics"},{"location":"#course-description","text":"An introduction to computational and numerical methods in physics. Includes an introduction to version control, documentation, collaborative code writing, and creating scientific quality plots. Numerical methods for differentiation, integration, curve fitting and optimization. Introduction to random variables and Monte Carlo methods. Examples are taken from problems in physics which cannot be solved using analytic methods only.","title":"Course Description"},{"location":"#course-topic-outline","text":"Introduction (Programming, Version Control and Documentation) Symbolic Tools and Plotting Numerical Methods for Differentiation","title":"Course Topic Outline"},{"location":"ch1_intro/","text":"Introduction Review of Programming We will mostly make use of the python programming language in this introduction and for much of the course (but not always as we will also look at Mathematica ). Since a basic course in programming is a pre-requisite for this course, some level of familiarity with programming is assumed. The first step is to make sure that you have the proper environment setup on your computer. Make sure that you have python 3 installed; also install the numpy package. One way to make sure that these two packages are installed is to install the Anaconda Python Distribution . Alternatively, for quick running of code on the web, you could make use of Google Colab , which will open a notebook interface in which you can run python code. Google Colab uses a modified versin of Jupyter Notebook ; you can try to install/run jupyter notebook on your computer if you find the notebook interface useful. Alternatively, Once you have the proper programming environment setup, let's begin with the following basic tasks that most programming languages can do - output, loop and condition. Printing Output Input Output import numpy import numpy as np # (1) print ( np . log10 ( 10 ), np . log ( 10 )) # (2) import the numerical library numpy for mathematical operations np.log10(10) calculates the base-10 logarithm whereas np.log(10) calculates the natural logarithm of 10. print function is used to print the two outputs to the screen. 1.0 2.302585092994046 You should expect two numbers as the output: one for log base 10 i.e. \\(\\log_{\\rm 10}\\) and the other for natural logarithm i.e. \\(\\ln(10)\\) . For the above code to run, you may save the code in a file with name such as filename.py and on the command line enter: python filename.py Depending on your installation of python, you may also have to install the additional library used in your code; for example, if you do not have the numpy library installed, you can install using pip install numpy The for loop Let us look at one more example python code to illustrate the use of variables and for loop. Input Output sum of integers from 1 to 100 total = 0 # (1) for i in range ( 1 , 101 ): # (2) total = total + i # (3) print ( total ) # (4) variable total is initially assigned a value of zero note the natural language-like syntax for for loop in python; also, note that range(1, 101) excludes 101 . note that indentation of code is important in python the total variable is printed on the screen once the program exits the for loop after adding 1 to 100. sum of integers from 1 to 100 5050 The if condition Consider the following python code that checks whether an integer is odd or even. Input Output check if an integer is odd or even def check_even ( n ): \"\"\"Checks if the given integer n is even Args: n: integer Returns: True if n is even, False else \"\"\" if ( n % 2 == 0 ): return True return False print ( check_even ( 9 ), check_even ( 10 )) check if an integer is odd or even False True In the code above we have also used def to define a new function. Inside the def function block, we have used three double-quote \"\"\" format for docstring . The while loop The while loop runs as long as the condition given in its syntax is satisfied. The while loop can be used instead of the for loop to get the sum of integers; see example below: Input Output sum of integers from 1 to 100 using while total = 0 i = 0 while ( i <= 100 ): total = total + i i = i + 1 print ( total ) sum of integers from 1 to 100 using while 5050 Fibonacci numbers Write a python code to print out Fibonacci numbers upto a certain value say all the Fibonacci numbers less than 10000. The first two Fibonacci numbers are 1,1 and the rule for Fibonacci sequence is that the next number is obtained by a sum of previous two numbers. Lists and Arrays In-built Lists in Python Input Output list example List1 = [ 1 , 2 , 3 ] List2 = [ \"red\" , \"blue\" , \"green\" ] List3 = [ - 1 , 0 , \"orange\" ] print ( List1 [ 0 ], List2 [ 1 ], List3 [ 2 ]) List1 . append ( 4 ) # (1) print ( List1 ) List1 . pop () # (2) print ( List1 ) Add an element to the list. Remove the last element of the list. list example 1 blue orange [ 1 , 2 , 3 , 4 ] [ 1 , 2 , 3 ] A list can contain different types of elements. As you have seen in the example above, List3 consists of both integers and an string. Elements can also be added or removed from a list i.e. a list can grow or shrink during the execution of a program. Arrays The array module in python supports an object type called Array that can do more mathematical operations than the in-built python lists. However, the numpy module has support for a similar object array with support for more mathematical operations (including vector and matrix operations). Therefore, we will look at the numpy.array object: Input Output simple numpy.array examples import numpy as np # first a simple 1D array arr1 = np . array ([ 1.0 , 2.0 , 3.0 ]) print ( arr1 ) # a simple 2D array arr2 = np . array ([[ 1.0 , 2.0 , 3.0 ], [ 1.5 , 2.5 , 3.5 ]]) print ( arr2 ) # to access the element of an array we can use indexing as follows: print ( arr2 [ 0 , 0 ]) # outputs 1.0 (the first row, first column) print ( arr2 [ 0 , 1 ]) # outputs 2.0 (the first row, second column) print ( arr1 [ 1 ]) # outputs 2.0 (the second element of a 1D array) simple numpy.array examples [[ 1. 2. 3. ] [ 1.5 2.5 3.5 ]] 1.0 2.0 2.0 Now, let us make use of the numpy.array and numpy.sum to calculate the sum of integers from 1 to 100. Input Output numpy.array example to sum integers from 1 to 100 import numpy as np arr3 = np . array ([ i for i in range ( 0 , 101 )]) print ( arr3 ) print ( np . sum ( arr3 )) numpy.array example to sum integers from 1 to 100 array ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ]) 5050 In the example above, instead of arr2 = np.array([i for i in range(0, 101)]) we could have used arr2 = np.array(range(0, 101)) or simply arr2 = range(0, 101) and still obtained the desired result of 5050 . However, the way the syntax is written in the example is more powerful than these substitutes. For example, you can obtain the sum of squares of integers from 1 to 100 \\(\\left(\\sum_{i=1}^{100} i^2\\right)\\) by the following code: arr3 = np . array ([ i ** 2.0 for i in range ( 0 , 101 )]) print ( np . sum ( arr3 )) Numpy arrays as vectors and matrices A numpy array of one dimension can be thought of as a vector, and numpy supports vector operations such as dot product. Input Output numpy array as a vector import numpy as np v1 = np . array ([ 1.0 , - 1.0 , 2.0 ]) v2 = np . array ([ - 1.0 , 1.0 , 2.0 ]) v1dotv2 = v1 . dot ( v2 ) # you could also use np.dot(v1, v2) print ( \"The dot product is: \" , v1dotv2 ) numpy array as a vector The dot product is : 2.0 Initializing a multidimensional array Sometimes it is useful to initialize a multidimensional array -- for example a \\(N\\times N\\) matrix with all entries as zeros. Such an array can be updated later in the code with appropriate values for each element as needed. The numpy.zeros(shape) function can be used to generate arrays of given shape filled with zeros. Input 1 Output 1 np . zeros ( 5 ) array ([ 0. , 0. , 0. , 0. , 0. ]) Multidimensional arrays can be generated by giving the shape -- for example a \\(m \\times n\\) matrix of zeros can be created using np.zeros((m,n)) Input 2 Output 2 np . zeros (( 2 , 2 )) array ([[ 0. , 0. ], [ 0. , 0. ]]) Similar to np.zeros , there is also np.ones that fills the array with ones. Version Control Computer codes (and even documents) may require updating at times. At the early stages of developing a computer code, the frequency of updates may be very high. Even for a matured piece of code, there may be maintenance updates that will require you to update the code time and again. Version control tools help us with this process. They can also be useful if we decide to revert a change at a later time and in case that multiple people are collaborating on the same piece of software or document at once. We will make use of github for version control. The underlying version control software utilized by github is called git . Please take the following github skills course to begin. Introduction to GitHub - Github Skills Documentation The code you write will likely be read by other people that may include friends, collegues, professors, customors and users. Therefore, good documentation of code is very important and perhaps even more so for large projects. Large projects typically also follow a certain style guide so that the code and documentation written by numerous contributors have consistent style. For example, there is PEP 8 Style Guide for Python Code and PEP 257 Docstring Conventions that are generally followed. Another popular style guide for python is the Google Python Style Guide . In this course, we will not be worrying about strictly following a style guide, but it is good to know that these exist and that you can make use of one if necessary.","title":"Introduction"},{"location":"ch1_intro/#introduction","text":"","title":"Introduction"},{"location":"ch1_intro/#review-of-programming","text":"We will mostly make use of the python programming language in this introduction and for much of the course (but not always as we will also look at Mathematica ). Since a basic course in programming is a pre-requisite for this course, some level of familiarity with programming is assumed. The first step is to make sure that you have the proper environment setup on your computer. Make sure that you have python 3 installed; also install the numpy package. One way to make sure that these two packages are installed is to install the Anaconda Python Distribution . Alternatively, for quick running of code on the web, you could make use of Google Colab , which will open a notebook interface in which you can run python code. Google Colab uses a modified versin of Jupyter Notebook ; you can try to install/run jupyter notebook on your computer if you find the notebook interface useful. Alternatively, Once you have the proper programming environment setup, let's begin with the following basic tasks that most programming languages can do - output, loop and condition.","title":"Review of Programming"},{"location":"ch1_intro/#printing-output","text":"Input Output import numpy import numpy as np # (1) print ( np . log10 ( 10 ), np . log ( 10 )) # (2) import the numerical library numpy for mathematical operations np.log10(10) calculates the base-10 logarithm whereas np.log(10) calculates the natural logarithm of 10. print function is used to print the two outputs to the screen. 1.0 2.302585092994046 You should expect two numbers as the output: one for log base 10 i.e. \\(\\log_{\\rm 10}\\) and the other for natural logarithm i.e. \\(\\ln(10)\\) . For the above code to run, you may save the code in a file with name such as filename.py and on the command line enter: python filename.py Depending on your installation of python, you may also have to install the additional library used in your code; for example, if you do not have the numpy library installed, you can install using pip install numpy","title":"Printing Output"},{"location":"ch1_intro/#the-for-loop","text":"Let us look at one more example python code to illustrate the use of variables and for loop. Input Output sum of integers from 1 to 100 total = 0 # (1) for i in range ( 1 , 101 ): # (2) total = total + i # (3) print ( total ) # (4) variable total is initially assigned a value of zero note the natural language-like syntax for for loop in python; also, note that range(1, 101) excludes 101 . note that indentation of code is important in python the total variable is printed on the screen once the program exits the for loop after adding 1 to 100. sum of integers from 1 to 100 5050","title":"The for loop"},{"location":"ch1_intro/#the-if-condition","text":"Consider the following python code that checks whether an integer is odd or even. Input Output check if an integer is odd or even def check_even ( n ): \"\"\"Checks if the given integer n is even Args: n: integer Returns: True if n is even, False else \"\"\" if ( n % 2 == 0 ): return True return False print ( check_even ( 9 ), check_even ( 10 )) check if an integer is odd or even False True In the code above we have also used def to define a new function. Inside the def function block, we have used three double-quote \"\"\" format for docstring .","title":"The if condition"},{"location":"ch1_intro/#the-while-loop","text":"The while loop runs as long as the condition given in its syntax is satisfied. The while loop can be used instead of the for loop to get the sum of integers; see example below: Input Output sum of integers from 1 to 100 using while total = 0 i = 0 while ( i <= 100 ): total = total + i i = i + 1 print ( total ) sum of integers from 1 to 100 using while 5050 Fibonacci numbers Write a python code to print out Fibonacci numbers upto a certain value say all the Fibonacci numbers less than 10000. The first two Fibonacci numbers are 1,1 and the rule for Fibonacci sequence is that the next number is obtained by a sum of previous two numbers.","title":"The while loop"},{"location":"ch1_intro/#lists-and-arrays","text":"","title":"Lists and Arrays"},{"location":"ch1_intro/#in-built-lists-in-python","text":"Input Output list example List1 = [ 1 , 2 , 3 ] List2 = [ \"red\" , \"blue\" , \"green\" ] List3 = [ - 1 , 0 , \"orange\" ] print ( List1 [ 0 ], List2 [ 1 ], List3 [ 2 ]) List1 . append ( 4 ) # (1) print ( List1 ) List1 . pop () # (2) print ( List1 ) Add an element to the list. Remove the last element of the list. list example 1 blue orange [ 1 , 2 , 3 , 4 ] [ 1 , 2 , 3 ] A list can contain different types of elements. As you have seen in the example above, List3 consists of both integers and an string. Elements can also be added or removed from a list i.e. a list can grow or shrink during the execution of a program.","title":"In-built Lists in Python"},{"location":"ch1_intro/#arrays","text":"The array module in python supports an object type called Array that can do more mathematical operations than the in-built python lists. However, the numpy module has support for a similar object array with support for more mathematical operations (including vector and matrix operations). Therefore, we will look at the numpy.array object: Input Output simple numpy.array examples import numpy as np # first a simple 1D array arr1 = np . array ([ 1.0 , 2.0 , 3.0 ]) print ( arr1 ) # a simple 2D array arr2 = np . array ([[ 1.0 , 2.0 , 3.0 ], [ 1.5 , 2.5 , 3.5 ]]) print ( arr2 ) # to access the element of an array we can use indexing as follows: print ( arr2 [ 0 , 0 ]) # outputs 1.0 (the first row, first column) print ( arr2 [ 0 , 1 ]) # outputs 2.0 (the first row, second column) print ( arr1 [ 1 ]) # outputs 2.0 (the second element of a 1D array) simple numpy.array examples [[ 1. 2. 3. ] [ 1.5 2.5 3.5 ]] 1.0 2.0 2.0 Now, let us make use of the numpy.array and numpy.sum to calculate the sum of integers from 1 to 100. Input Output numpy.array example to sum integers from 1 to 100 import numpy as np arr3 = np . array ([ i for i in range ( 0 , 101 )]) print ( arr3 ) print ( np . sum ( arr3 )) numpy.array example to sum integers from 1 to 100 array ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ]) 5050 In the example above, instead of arr2 = np.array([i for i in range(0, 101)]) we could have used arr2 = np.array(range(0, 101)) or simply arr2 = range(0, 101) and still obtained the desired result of 5050 . However, the way the syntax is written in the example is more powerful than these substitutes. For example, you can obtain the sum of squares of integers from 1 to 100 \\(\\left(\\sum_{i=1}^{100} i^2\\right)\\) by the following code: arr3 = np . array ([ i ** 2.0 for i in range ( 0 , 101 )]) print ( np . sum ( arr3 ))","title":"Arrays"},{"location":"ch1_intro/#numpy-arrays-as-vectors-and-matrices","text":"A numpy array of one dimension can be thought of as a vector, and numpy supports vector operations such as dot product. Input Output numpy array as a vector import numpy as np v1 = np . array ([ 1.0 , - 1.0 , 2.0 ]) v2 = np . array ([ - 1.0 , 1.0 , 2.0 ]) v1dotv2 = v1 . dot ( v2 ) # you could also use np.dot(v1, v2) print ( \"The dot product is: \" , v1dotv2 ) numpy array as a vector The dot product is : 2.0","title":"Numpy arrays as vectors and matrices"},{"location":"ch1_intro/#initializing-a-multidimensional-array","text":"Sometimes it is useful to initialize a multidimensional array -- for example a \\(N\\times N\\) matrix with all entries as zeros. Such an array can be updated later in the code with appropriate values for each element as needed. The numpy.zeros(shape) function can be used to generate arrays of given shape filled with zeros. Input 1 Output 1 np . zeros ( 5 ) array ([ 0. , 0. , 0. , 0. , 0. ]) Multidimensional arrays can be generated by giving the shape -- for example a \\(m \\times n\\) matrix of zeros can be created using np.zeros((m,n)) Input 2 Output 2 np . zeros (( 2 , 2 )) array ([[ 0. , 0. ], [ 0. , 0. ]]) Similar to np.zeros , there is also np.ones that fills the array with ones.","title":"Initializing a multidimensional array"},{"location":"ch1_intro/#version-control","text":"Computer codes (and even documents) may require updating at times. At the early stages of developing a computer code, the frequency of updates may be very high. Even for a matured piece of code, there may be maintenance updates that will require you to update the code time and again. Version control tools help us with this process. They can also be useful if we decide to revert a change at a later time and in case that multiple people are collaborating on the same piece of software or document at once. We will make use of github for version control. The underlying version control software utilized by github is called git . Please take the following github skills course to begin. Introduction to GitHub - Github Skills","title":"Version Control"},{"location":"ch1_intro/#documentation","text":"The code you write will likely be read by other people that may include friends, collegues, professors, customors and users. Therefore, good documentation of code is very important and perhaps even more so for large projects. Large projects typically also follow a certain style guide so that the code and documentation written by numerous contributors have consistent style. For example, there is PEP 8 Style Guide for Python Code and PEP 257 Docstring Conventions that are generally followed. Another popular style guide for python is the Google Python Style Guide . In this course, we will not be worrying about strictly following a style guide, but it is good to know that these exist and that you can make use of one if necessary.","title":"Documentation"},{"location":"ch2_symbolic/","text":"Symbolic and Plotting Tools We will consider symbolic math using Mathematica . Alternatives to Mathematica for symbolic mathematics include Maple , symbolic toolbox for Matlab , and the open source python package sympy . Symbolic Math using Mathematica Mathematica is a popular tool for symbolic math, and is useful for many mathematical tasks such as calculating derivatives and integrals. SUNY Plattsburgh students can install Mathematica on their personal computer. See instructions here . Performing mathematical calculations in Mathematica Try typing D[x^2, x] and pressing Shift + Enter to evaluate the cell: Input Output D [ x ^ 2 , x ] 2 x The command D[x^2, x] calculates the derivative of \\(x^2\\) with respect to \\(x\\) . To calculate an integral, use the Integrate command as: Input Output Integrate [ 2 x , x ] x ^ 2 Mathematica can perform many popular integrals that show up in various topics of physics and mathematics. For example: Consider the Gaussian (normal) distribution with one standard deviation ( \\(\\sigma=1\\) ) and zero mean \\((\\mu=0)\\) : \\[ \\mathcal{N}(x) = \\frac{1}{\\sqrt{2 \\pi}} e^{-{x^2}/{2}} \\] Suppose we want to find the integral of this function from \\(-\\infty\\) to \\(\\infty\\) . Such a definite integral will result in the area under the curve between the limits. Following the same syntax as above, using Sqrt[2 Pi] for \\(\\sqrt{2 \\pi}\\) and using Exp[-x^2] for \\(e^{-x^2}\\) , attempt to calculate the definite integral: \\[ \\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , - Infinity , Infinity }] 1 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx =1\\] The factor of \\(1/\\sqrt{2 \\pi}\\) is used to normalize the distribution \\(P(x)\\) so that it can be used as a probability density function (pdf). The integral of a pdf over all possible values should result in one. Now calculate another definite integral of the same integrand but taking the limits from \\(-1\\) to \\(1\\) i.e. calculate the definite integral: \\[ \\frac{1}{\\sqrt{2\\pi}}\\int_{-1}^{1} e^{-x^2/2} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }] Erf [ 1 / Sqrt [ 2 ]] where Erf is the error function . A numerical output in mathematica can be forced by either using N[] or //N as follows: Input Output N [ Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }]] 0.682689 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-1}^1 e^{-x^2/2} dx = {\\rm Erf}\\left[\\frac{1}{\\sqrt{2}}\\right] = 0.682689\\] Using Mathematica now you should be able to obtain the following results: \\[ \\int_{-1}^1 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.682689 \\] \\[ \\int_{-2}^2 \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx = 0.9545 \\] \\[ \\int_{-3}^3 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.9973 \\] Next we will learn some plotting syntax in Mathematica and use them to plot the integrand used above \\(\\mathcal{N}(x)=e^{-x^2/2}/\\sqrt{2 \\pi}\\) to better understand the normal probability density function. Plotting in Mathematica Input Output Plot [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -5 , 5 }, AxesLabel -> { \"x\" , \"N(x)\" }, PlotLabel -> \"Gaussian Distribution\" ] Plotting in Matplotlib matplotlib is a widely used python plotting library. It can be used in google colab , but you may need to install it ( see instructions ) if you have not already installed matplotlib on your computer. The plot of the normal distribution \\(\\mathcal{N}(x)\\) can be made in matplotlib using the following code: Input Output Making plot using matplotlib import matplotlib.pyplot as plt # (1) import numpy as np # (2) x = np . arange ( - 5 , 5 , 0.01 ) # (3) y = np . exp ( - x * x / 2 ) / np . sqrt ( 2 * np . pi ) # (4) plt . plot ( x , y ) # (5) plt . xlabel ( \"$x$\" ) # (6) plt . ylabel ( \"$\\mathcal {N} (x)$\" ) # (7) plt . title ( \"Gaussian Distribution\" ) # (8) plt . show () # (9) import the pyplot plotting interface from matplotlib library as plt import the numerical python library numpy as np for various array and mathematical functions create an array from -5 to 5 in increments of 0.01; i.e. \\(\\frac{5-(-5)}{0.01}=1000\\) numbers in total. The number of items in the array x can be checked either using len(x) or using np.size(x) generate a numpy array for \\(y=\\mathcal{N}(x)\\) make the plot using two arrays x and y add label on the x axis; the dollar signs means we use LaTex syntax for mathematical typesetting. add label on the y axis add plot title plt.show() may or may not be needed depending on the backend used for plotting; e.g. not needed in notebook interfaces such as jupyter/google colab. We can also plot vector fields using matplotlib . Let us plot the electric field due to a couple of simple charge configurations. Here we will use the streamplot function. Plotting a vector field First think about what you need to do to make such a field plot given that you have a function in matplotlib that directly generates a field plot if you provide it with vector field values in a grid. In 2D you will need to provide the \\(x-\\) component, \\(E_x\\) and the \\(y-\\) component, \\(E_y\\) of the electric field vector at each point. Recall: \\[ \\vec{E}(x,y) = \\frac{k q}{r^2} \\hat{r} = \\frac{k q}{r^3} \\left( x \\hat{i} + y \\hat{j}\\right)\\] is the electric field at a point \\((x,y)\\) due to a charge \\(q\\) at the origin, where \\(r=\\sqrt{x^2+y^2}\\) . Similarly, if the point charge is located at \\((x_0, y_0)\\) rather than the origin: \\[ \\vec{E}(x,y) = \\frac{k q}{r^3} \\left[ (x-x_0)\\hat{i}+(y-y_0)\\hat{j}\\right] \\] where, \\(r = \\sqrt{(x-x_0)^2 + (y-y_0)^2}\\) . Next, we need to understand the arguments of the streamplot function. In the documentation it is mentioned that at least four arguments are required: matplotlib.pyplot.streamplot(x, y, u, v) where x and y can be 1D arrays that form the grid of the vector plot, but u and v must be 2D arrays (like a matrix) providing the \\(x\\) and \\(y\\) components of the vector field at each point. Let us first brainstorm one of the ways to obtain a vector lines plot using streamplot due to a unit positive charge at the origin. For that we will use a mix of programming and natural language without worrying about the syntax, but focusing on the algorithm; we may call this a pseudocode. pseudocode q = 1 k = 1 xlist, ylist = -5 to 5 with 0.1 stepsize Ex, Ey = 100x100 arrays (matrices) with all elements as zeros i = 0 for x in xlist: j = 0 for y in ylist: rcubed = sqrt(x*x+y*y)**3.0 Ex[j,i] = k * q * x / rcubed Ey[j,i] = k * q * y / rcubed j = j + 1 i = i + 1 streamplot(x, y, Ex, Ey) We used Ex[j,i] rather than Ex[i,j] because streamplot requires that these matrices have \"the number of rows and columns match the length of y and x, respectively.\" Now, let's convert the pseudocode to a python code. Python Code Output Electric field lines due to a charge at origin import matplotlib.pyplot as plt import numpy as np q = 1 k = 1 xlist = np . arange ( - 5 , 5 , 0.5 ) ylist = np . arange ( - 5 , 5 , 0.5 ) Ex = np . empty (( len ( ylist ), len ( xlist ))) Ey = np . empty (( len ( ylist ), len ( xlist ))) i = 0 for x in xlist : j = 0 for y in ylist : rcubed = np . sqrt ( x * x + y * y ) ** 3.0 Ex [ j , i ] = k * q * x / rcubed Ey [ j , i ] = k * q * y / rcubed j = j + 1 i = i + 1 plt . streamplot ( xlist , ylist , Ex , Ey , linewidth = 1 , density = 2 , arrowstyle = \"->\" ) Notice that you can specify the linewidth , the density and the arrowstyle in the streamplot function as in the example above, but these are optional arguments. Assignment: Implement a streamplot plot for the electric field lines due to two point charges separated by a distance; for example, one charge is at \\((1,0)\\) and the other is at \\((-1, 0)\\) .","title":"Symbolic and Plotting Tools"},{"location":"ch2_symbolic/#symbolic-and-plotting-tools","text":"We will consider symbolic math using Mathematica . Alternatives to Mathematica for symbolic mathematics include Maple , symbolic toolbox for Matlab , and the open source python package sympy .","title":"Symbolic and Plotting Tools"},{"location":"ch2_symbolic/#symbolic-math-using-mathematica","text":"Mathematica is a popular tool for symbolic math, and is useful for many mathematical tasks such as calculating derivatives and integrals. SUNY Plattsburgh students can install Mathematica on their personal computer. See instructions here .","title":"Symbolic Math using Mathematica"},{"location":"ch2_symbolic/#performing-mathematical-calculations-in-mathematica","text":"Try typing D[x^2, x] and pressing Shift + Enter to evaluate the cell: Input Output D [ x ^ 2 , x ] 2 x The command D[x^2, x] calculates the derivative of \\(x^2\\) with respect to \\(x\\) . To calculate an integral, use the Integrate command as: Input Output Integrate [ 2 x , x ] x ^ 2 Mathematica can perform many popular integrals that show up in various topics of physics and mathematics. For example: Consider the Gaussian (normal) distribution with one standard deviation ( \\(\\sigma=1\\) ) and zero mean \\((\\mu=0)\\) : \\[ \\mathcal{N}(x) = \\frac{1}{\\sqrt{2 \\pi}} e^{-{x^2}/{2}} \\] Suppose we want to find the integral of this function from \\(-\\infty\\) to \\(\\infty\\) . Such a definite integral will result in the area under the curve between the limits. Following the same syntax as above, using Sqrt[2 Pi] for \\(\\sqrt{2 \\pi}\\) and using Exp[-x^2] for \\(e^{-x^2}\\) , attempt to calculate the definite integral: \\[ \\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , - Infinity , Infinity }] 1 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-\\infty}^\\infty \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx =1\\] The factor of \\(1/\\sqrt{2 \\pi}\\) is used to normalize the distribution \\(P(x)\\) so that it can be used as a probability density function (pdf). The integral of a pdf over all possible values should result in one. Now calculate another definite integral of the same integrand but taking the limits from \\(-1\\) to \\(1\\) i.e. calculate the definite integral: \\[ \\frac{1}{\\sqrt{2\\pi}}\\int_{-1}^{1} e^{-x^2/2} dx \\] Check your Mathematica code and output Input Output Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }] Erf [ 1 / Sqrt [ 2 ]] where Erf is the error function . A numerical output in mathematica can be forced by either using N[] or //N as follows: Input Output N [ Integrate [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -1 , 1 }]] 0.682689 That is: \\[\\frac{1}{\\sqrt{2 \\pi}}\\int_{-1}^1 e^{-x^2/2} dx = {\\rm Erf}\\left[\\frac{1}{\\sqrt{2}}\\right] = 0.682689\\] Using Mathematica now you should be able to obtain the following results: \\[ \\int_{-1}^1 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.682689 \\] \\[ \\int_{-2}^2 \\frac{e^{-x^2/2}}{\\sqrt{2 \\pi}} dx = 0.9545 \\] \\[ \\int_{-3}^3 \\frac{e^{-x^2/2}}{\\sqrt{2\\pi}} dx = 0.9973 \\] Next we will learn some plotting syntax in Mathematica and use them to plot the integrand used above \\(\\mathcal{N}(x)=e^{-x^2/2}/\\sqrt{2 \\pi}\\) to better understand the normal probability density function.","title":"Performing mathematical calculations in Mathematica"},{"location":"ch2_symbolic/#plotting-in-mathematica","text":"Input Output Plot [( 1 / Sqrt [ 2 Pi ]) Exp [ - ( x ^ 2 ) / 2 ], { x , -5 , 5 }, AxesLabel -> { \"x\" , \"N(x)\" }, PlotLabel -> \"Gaussian Distribution\" ]","title":"Plotting in Mathematica"},{"location":"ch2_symbolic/#plotting-in-matplotlib","text":"matplotlib is a widely used python plotting library. It can be used in google colab , but you may need to install it ( see instructions ) if you have not already installed matplotlib on your computer. The plot of the normal distribution \\(\\mathcal{N}(x)\\) can be made in matplotlib using the following code: Input Output Making plot using matplotlib import matplotlib.pyplot as plt # (1) import numpy as np # (2) x = np . arange ( - 5 , 5 , 0.01 ) # (3) y = np . exp ( - x * x / 2 ) / np . sqrt ( 2 * np . pi ) # (4) plt . plot ( x , y ) # (5) plt . xlabel ( \"$x$\" ) # (6) plt . ylabel ( \"$\\mathcal {N} (x)$\" ) # (7) plt . title ( \"Gaussian Distribution\" ) # (8) plt . show () # (9) import the pyplot plotting interface from matplotlib library as plt import the numerical python library numpy as np for various array and mathematical functions create an array from -5 to 5 in increments of 0.01; i.e. \\(\\frac{5-(-5)}{0.01}=1000\\) numbers in total. The number of items in the array x can be checked either using len(x) or using np.size(x) generate a numpy array for \\(y=\\mathcal{N}(x)\\) make the plot using two arrays x and y add label on the x axis; the dollar signs means we use LaTex syntax for mathematical typesetting. add label on the y axis add plot title plt.show() may or may not be needed depending on the backend used for plotting; e.g. not needed in notebook interfaces such as jupyter/google colab. We can also plot vector fields using matplotlib . Let us plot the electric field due to a couple of simple charge configurations. Here we will use the streamplot function. Plotting a vector field First think about what you need to do to make such a field plot given that you have a function in matplotlib that directly generates a field plot if you provide it with vector field values in a grid. In 2D you will need to provide the \\(x-\\) component, \\(E_x\\) and the \\(y-\\) component, \\(E_y\\) of the electric field vector at each point. Recall: \\[ \\vec{E}(x,y) = \\frac{k q}{r^2} \\hat{r} = \\frac{k q}{r^3} \\left( x \\hat{i} + y \\hat{j}\\right)\\] is the electric field at a point \\((x,y)\\) due to a charge \\(q\\) at the origin, where \\(r=\\sqrt{x^2+y^2}\\) . Similarly, if the point charge is located at \\((x_0, y_0)\\) rather than the origin: \\[ \\vec{E}(x,y) = \\frac{k q}{r^3} \\left[ (x-x_0)\\hat{i}+(y-y_0)\\hat{j}\\right] \\] where, \\(r = \\sqrt{(x-x_0)^2 + (y-y_0)^2}\\) . Next, we need to understand the arguments of the streamplot function. In the documentation it is mentioned that at least four arguments are required: matplotlib.pyplot.streamplot(x, y, u, v) where x and y can be 1D arrays that form the grid of the vector plot, but u and v must be 2D arrays (like a matrix) providing the \\(x\\) and \\(y\\) components of the vector field at each point. Let us first brainstorm one of the ways to obtain a vector lines plot using streamplot due to a unit positive charge at the origin. For that we will use a mix of programming and natural language without worrying about the syntax, but focusing on the algorithm; we may call this a pseudocode. pseudocode q = 1 k = 1 xlist, ylist = -5 to 5 with 0.1 stepsize Ex, Ey = 100x100 arrays (matrices) with all elements as zeros i = 0 for x in xlist: j = 0 for y in ylist: rcubed = sqrt(x*x+y*y)**3.0 Ex[j,i] = k * q * x / rcubed Ey[j,i] = k * q * y / rcubed j = j + 1 i = i + 1 streamplot(x, y, Ex, Ey) We used Ex[j,i] rather than Ex[i,j] because streamplot requires that these matrices have \"the number of rows and columns match the length of y and x, respectively.\" Now, let's convert the pseudocode to a python code. Python Code Output Electric field lines due to a charge at origin import matplotlib.pyplot as plt import numpy as np q = 1 k = 1 xlist = np . arange ( - 5 , 5 , 0.5 ) ylist = np . arange ( - 5 , 5 , 0.5 ) Ex = np . empty (( len ( ylist ), len ( xlist ))) Ey = np . empty (( len ( ylist ), len ( xlist ))) i = 0 for x in xlist : j = 0 for y in ylist : rcubed = np . sqrt ( x * x + y * y ) ** 3.0 Ex [ j , i ] = k * q * x / rcubed Ey [ j , i ] = k * q * y / rcubed j = j + 1 i = i + 1 plt . streamplot ( xlist , ylist , Ex , Ey , linewidth = 1 , density = 2 , arrowstyle = \"->\" ) Notice that you can specify the linewidth , the density and the arrowstyle in the streamplot function as in the example above, but these are optional arguments. Assignment: Implement a streamplot plot for the electric field lines due to two point charges separated by a distance; for example, one charge is at \\((1,0)\\) and the other is at \\((-1, 0)\\) .","title":"Plotting in Matplotlib"},{"location":"ch3_numeric/","text":"Numerical Methods for Differentiation First, let us look into some methods for calculating numerical derivatives. Finite Differences Numerical derivatives of a function \\(f(x)\\) at \\(x=x_0\\) can be calculated by the method of finite differences. Recall that the derivative \\(f'(x_0)\\) tells you about the slope of the tangent at \\(x=x_0\\) . Such a slope can be drawn by drawing a line by considering two nearby points on either side of \\(P(x_0, f(x_0))\\) : \\(P_-(x_0-h, f(x_0-h))\\) and \\(P_+(x_0+h, f(x_0+h))\\) where \\(h\\) is small. Therefore, the estimate for the slope and therefore the derivative \\(f'(x_0)\\) becomes: \\[f'(x_0) = \\frac{f(x_0+h)-f(x_0-h)}{x_0+h-(x_0-h)}=\\frac{f(x_0+h)-f(x_0-h)}{2 h}\\] You should convince yourself that as \\(h\\rightarrow 0\\) , your estimate approaches the exact derivative. Sample code and accuracy check Python code for central difference Accuracy check central difference derivative def central_diff_sin ( x , h ): \"\"\"Calculate numerical derivative of sin(x) using central difference Parameters ---------- x : real angle in radians h : real step size in radians \"\"\" import numpy as np return ( np . sin ( x + h ) - np . sin ( x - h )) / ( 2 * h ) x h central_diff_sin(x,h) cos(x) (actual) percent accuracy 0.3 0.04 0.9550818 0.9553365 0.026660 0.3 0.03 0.9551932 0.9553365 0.014999 0.3 0.02 0.9552728 0.9553365 0.006667 0.3 0.01 0.9553206 0.9553365 0.001663 Estimating accuracy In the example above, we knew the correct value of the operation that we were numerically calculating since \\(\\frac{d\\sin(x)}{dx} = \\cos x\\) . However, the actual value of the numerical methods lies when calculating quantities that do not have an easy analytic solution. In such cases, it is useful to be able to have some knowledge of the error in the numerical estimate. We can estimate the error made when numerically calculating derivatives using the central difference method by using Taylor expansion. Leading order error for central difference Proof using Taylor expansion The leading order approximation error is given by \\[\\epsilon = \\frac{|h^2 f'''(x_0)|}{6}\\] The expression shows that the approximation error \\(\\epsilon\\) decreases as \\(h\\) decreases. For our example above with \\(f(x)=\\sin(x)\\) , \\(x_0=0.3\\) and \\(h=0.01\\) : \\[\\epsilon = \\frac{|(0.01)^2 (\\cos{0.1})|}{6} = 0.00001658 = 0.001658\\% \\] which is close to the actual percent accuracy calculated earlier. \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] we obtain, \\[ \\frac{f(x_0+h)-f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2 f'''(x_0)}{6} + \\dots \\] Forward difference numerical derivative Work out a forward difference approach (i.e. use the slope of line made by \\(P_+\\) and \\(P\\) ) to taking numerical derivative and compare it with the central difference method discussed above in terms of accuracy. Sampled function Suppose you have a sampled function i.e. the function values are known (let's say at a regular interval of \\(h\\) ). Which one is a better approach -- central difference or forward difference for calculating numerical derivatives?","title":"Numerical Derivatives"},{"location":"ch3_numeric/#numerical-methods-for-differentiation","text":"First, let us look into some methods for calculating numerical derivatives.","title":"Numerical Methods for Differentiation"},{"location":"ch3_numeric/#finite-differences","text":"Numerical derivatives of a function \\(f(x)\\) at \\(x=x_0\\) can be calculated by the method of finite differences. Recall that the derivative \\(f'(x_0)\\) tells you about the slope of the tangent at \\(x=x_0\\) . Such a slope can be drawn by drawing a line by considering two nearby points on either side of \\(P(x_0, f(x_0))\\) : \\(P_-(x_0-h, f(x_0-h))\\) and \\(P_+(x_0+h, f(x_0+h))\\) where \\(h\\) is small. Therefore, the estimate for the slope and therefore the derivative \\(f'(x_0)\\) becomes: \\[f'(x_0) = \\frac{f(x_0+h)-f(x_0-h)}{x_0+h-(x_0-h)}=\\frac{f(x_0+h)-f(x_0-h)}{2 h}\\] You should convince yourself that as \\(h\\rightarrow 0\\) , your estimate approaches the exact derivative.","title":"Finite Differences"},{"location":"ch3_numeric/#sample-code-and-accuracy-check","text":"Python code for central difference Accuracy check central difference derivative def central_diff_sin ( x , h ): \"\"\"Calculate numerical derivative of sin(x) using central difference Parameters ---------- x : real angle in radians h : real step size in radians \"\"\" import numpy as np return ( np . sin ( x + h ) - np . sin ( x - h )) / ( 2 * h ) x h central_diff_sin(x,h) cos(x) (actual) percent accuracy 0.3 0.04 0.9550818 0.9553365 0.026660 0.3 0.03 0.9551932 0.9553365 0.014999 0.3 0.02 0.9552728 0.9553365 0.006667 0.3 0.01 0.9553206 0.9553365 0.001663","title":"Sample code and accuracy check"},{"location":"ch3_numeric/#estimating-accuracy","text":"In the example above, we knew the correct value of the operation that we were numerically calculating since \\(\\frac{d\\sin(x)}{dx} = \\cos x\\) . However, the actual value of the numerical methods lies when calculating quantities that do not have an easy analytic solution. In such cases, it is useful to be able to have some knowledge of the error in the numerical estimate. We can estimate the error made when numerically calculating derivatives using the central difference method by using Taylor expansion. Leading order error for central difference Proof using Taylor expansion The leading order approximation error is given by \\[\\epsilon = \\frac{|h^2 f'''(x_0)|}{6}\\] The expression shows that the approximation error \\(\\epsilon\\) decreases as \\(h\\) decreases. For our example above with \\(f(x)=\\sin(x)\\) , \\(x_0=0.3\\) and \\(h=0.01\\) : \\[\\epsilon = \\frac{|(0.01)^2 (\\cos{0.1})|}{6} = 0.00001658 = 0.001658\\% \\] which is close to the actual percent accuracy calculated earlier. \\[ f(x_0+h) = f(x_0) + h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} + \\frac{h^3 f'''(x_0)}{6} + \\dots \\] \\[ f(x_0-h) = f(x_0) - h f'(x_0)+ \\frac{h^2 f''(x_0)}{2} - \\frac{h^3 f'''(x_0)}{6} + \\dots\\] we obtain, \\[ \\frac{f(x_0+h)-f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2 f'''(x_0)}{6} + \\dots \\] Forward difference numerical derivative Work out a forward difference approach (i.e. use the slope of line made by \\(P_+\\) and \\(P\\) ) to taking numerical derivative and compare it with the central difference method discussed above in terms of accuracy. Sampled function Suppose you have a sampled function i.e. the function values are known (let's say at a regular interval of \\(h\\) ). Which one is a better approach -- central difference or forward difference for calculating numerical derivatives?","title":"Estimating accuracy"},{"location":"ch3_numericint/","text":"Numerical Methods for Integration Numerical integrations are commonplace in scientific modeling and simulations. If several integrations have to be calculated, not only accuracy and precision but the speed at which those can be obtained becomes important. We will attempt to understand all three concepts (accuracy, precision and the speed of calculation) in the context of three methods of numerical integrations given below. Working with one dimensional integrals, our goal will be to approximate the definite integral: \\[ I(a, b) = \\int_a^b f(x)\\ dx. \\] Trapezoid rule In the trapezoid rule, the integral is approximated by adding the areas of many trapezoids. Simpson's rule Adaptive Integration","title":"Numerical Methods for Integration"},{"location":"ch3_numericint/#numerical-methods-for-integration","text":"Numerical integrations are commonplace in scientific modeling and simulations. If several integrations have to be calculated, not only accuracy and precision but the speed at which those can be obtained becomes important. We will attempt to understand all three concepts (accuracy, precision and the speed of calculation) in the context of three methods of numerical integrations given below. Working with one dimensional integrals, our goal will be to approximate the definite integral: \\[ I(a, b) = \\int_a^b f(x)\\ dx. \\]","title":"Numerical Methods for Integration"},{"location":"ch3_numericint/#trapezoid-rule","text":"In the trapezoid rule, the integral is approximated by adding the areas of many trapezoids.","title":"Trapezoid rule"},{"location":"ch3_numericint/#simpsons-rule","text":"","title":"Simpson's rule"},{"location":"ch3_numericint/#adaptive-integration","text":"","title":"Adaptive Integration"},{"location":"ch4_fitting/","text":"Curve fitting and Optimization Least square polynomial fitting Local Optimization Global Optimization","title":"Curve fitting and Optimization"},{"location":"ch4_fitting/#curve-fitting-and-optimization","text":"","title":"Curve fitting and Optimization"},{"location":"ch4_fitting/#least-square-polynomial-fitting","text":"","title":"Least square polynomial fitting"},{"location":"ch4_fitting/#local-optimization","text":"","title":"Local Optimization"},{"location":"ch4_fitting/#global-optimization","text":"","title":"Global Optimization"},{"location":"ch5_fouriertransform/","text":"Fourier Transform and its Applications","title":"Fourier Transform and its Applications"},{"location":"ch5_fouriertransform/#fourier-transform-and-its-applications","text":"","title":"Fourier Transform and its Applications"},{"location":"ch6_montecarlo/","text":"Monte Carlo Methods Random numbers Consider the output of the following code: random module import random random . seed ( 1000 ) print ( random . random (), random . random ()) The output will be two numbers printed on the screen. The random.random() command gives you a random number in the range [0.0, 1.0) . The likelihood of getting a particular value between 0 and 1 is the same. In statistical language, such a likelihood/probability is called a uniform distribution. If you want to get a random number in a different range, say [a, b] , you can either use the result of random . random () and rescale it appropriately, or directly use the function random . uniform ( a , b ) . Use of random . seed () : If you use the same seed number (argument) in calling random . seed ( seed ) before calling random . random () , the output is identical for the same seed . Because the returned random numbers depend on the seed , the number generator used by the random module is called a pseudo- random number generator. Such a generator is useful if you have to reproduce results (e.g. simulation) at a later time. If you do not provide an argument to random.seed or set random.seed(None) , the current system time is used as a proxy to a random seed and you will get different results each time you call random.random() . Estimating area using random numbers We can make use of random numbers to estimate areas. Suppose we want to estimate the area of the unit circle. Area of a unit circle \\[ A = \\pi r ^2 = \\pi (1)^2 = \\pi \\] In this case, we know the answer is \\(\\pi\\) . Therefore, we can frame this exercise as a method to estimate the numerical value of \\(\\pi\\) as well. Consider a unit circle embedded in a square. Now, in each step, we will generate two random numbers \\((x, y)\\) inside the embedding square, and check whether this randomly generated point lies inside of the unit circle or outside. Then an estimate of the area of the unit circle can be made: \\[ A = \\left( \\frac{\\rm points\\ inside\\ the\\ circle}{\\rm total\\ points} \\right) \\times {\\rm area\\ of\\ embedding\\ square}\\] Total Points: 0 Points Inside: 0 Area Estimate: Refresh the page to estimate using a new set of random points. var canvas = document.getElementById('canvas1') var NN = document.getElementById('NP') if (canvas.getContext) { var ctx = canvas.getContext('2d'); } function randomPoint() { x = Math.random()*200+50; y = Math.random()*200+50; if ((x-150)*(x-150)+(y-150)*(y-150)<=10000) { pts = pts + 1; ctx.fillStyle=\"green\"; } else { ctx.fillStyle=\"blue\"; } total = total + 1; ctx.fillRect(x, y, 1, 1); document.getElementById('label1').innerHTML = pts; document.getElementById('label2').innerHTML = total; Area = 4*pts/total document.getElementById('Aest').innerHTML = Area; } function calcpi() { ctx.clearRect(0, 0, 300, 300); ctx.beginPath(); ctx.strokeStyle=\"blue\"; ctx.rect(50, 50, 200, 200); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=\"red\"; ctx.arc(150, 150, 100, 2*Math.PI, false); ctx.stroke(); pts = 0; total = 0; for (let i = 0; i < NN.value; i++) { randomPoint(); ctx.stroke(); } } calcpi(); Python code to estimate \\(\\pi\\) Estimate area of a unit circle def pi_estimate ( total = 1000 ): pts_in = 0 for i in range ( total ): x = random . uniform ( - 1 , 1 ) y = random . uniform ( - 1 , 1 ) if ( x ** 2.0 + y ** 2.0 <= 1.0 ): pts_in = pts_in + 1.0 return 4.0 * pts_in / total print ( pi_estimate ()) Increasing the number of points used through the total argument in the pi_estimate function improves the estimate. If \\(N\\) is the number of points used, the standard error scales as \\(1/\\sqrt{N}\\) . Monte Carlo Integration Markov Chain Monte Carlo (MCMC) Examples","title":"Monte Carlo Methods"},{"location":"ch6_montecarlo/#monte-carlo-methods","text":"","title":"Monte Carlo Methods"},{"location":"ch6_montecarlo/#random-numbers","text":"Consider the output of the following code: random module import random random . seed ( 1000 ) print ( random . random (), random . random ()) The output will be two numbers printed on the screen. The random.random() command gives you a random number in the range [0.0, 1.0) . The likelihood of getting a particular value between 0 and 1 is the same. In statistical language, such a likelihood/probability is called a uniform distribution. If you want to get a random number in a different range, say [a, b] , you can either use the result of random . random () and rescale it appropriately, or directly use the function random . uniform ( a , b ) . Use of random . seed () : If you use the same seed number (argument) in calling random . seed ( seed ) before calling random . random () , the output is identical for the same seed . Because the returned random numbers depend on the seed , the number generator used by the random module is called a pseudo- random number generator. Such a generator is useful if you have to reproduce results (e.g. simulation) at a later time. If you do not provide an argument to random.seed or set random.seed(None) , the current system time is used as a proxy to a random seed and you will get different results each time you call random.random() .","title":"Random numbers"},{"location":"ch6_montecarlo/#estimating-area-using-random-numbers","text":"We can make use of random numbers to estimate areas. Suppose we want to estimate the area of the unit circle. Area of a unit circle \\[ A = \\pi r ^2 = \\pi (1)^2 = \\pi \\] In this case, we know the answer is \\(\\pi\\) . Therefore, we can frame this exercise as a method to estimate the numerical value of \\(\\pi\\) as well. Consider a unit circle embedded in a square. Now, in each step, we will generate two random numbers \\((x, y)\\) inside the embedding square, and check whether this randomly generated point lies inside of the unit circle or outside. Then an estimate of the area of the unit circle can be made: \\[ A = \\left( \\frac{\\rm points\\ inside\\ the\\ circle}{\\rm total\\ points} \\right) \\times {\\rm area\\ of\\ embedding\\ square}\\] Total Points: 0 Points Inside: 0 Area Estimate: Refresh the page to estimate using a new set of random points. var canvas = document.getElementById('canvas1') var NN = document.getElementById('NP') if (canvas.getContext) { var ctx = canvas.getContext('2d'); } function randomPoint() { x = Math.random()*200+50; y = Math.random()*200+50; if ((x-150)*(x-150)+(y-150)*(y-150)<=10000) { pts = pts + 1; ctx.fillStyle=\"green\"; } else { ctx.fillStyle=\"blue\"; } total = total + 1; ctx.fillRect(x, y, 1, 1); document.getElementById('label1').innerHTML = pts; document.getElementById('label2').innerHTML = total; Area = 4*pts/total document.getElementById('Aest').innerHTML = Area; } function calcpi() { ctx.clearRect(0, 0, 300, 300); ctx.beginPath(); ctx.strokeStyle=\"blue\"; ctx.rect(50, 50, 200, 200); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle=\"red\"; ctx.arc(150, 150, 100, 2*Math.PI, false); ctx.stroke(); pts = 0; total = 0; for (let i = 0; i < NN.value; i++) { randomPoint(); ctx.stroke(); } } calcpi(); Python code to estimate \\(\\pi\\) Estimate area of a unit circle def pi_estimate ( total = 1000 ): pts_in = 0 for i in range ( total ): x = random . uniform ( - 1 , 1 ) y = random . uniform ( - 1 , 1 ) if ( x ** 2.0 + y ** 2.0 <= 1.0 ): pts_in = pts_in + 1.0 return 4.0 * pts_in / total print ( pi_estimate ()) Increasing the number of points used through the total argument in the pi_estimate function improves the estimate. If \\(N\\) is the number of points used, the standard error scales as \\(1/\\sqrt{N}\\) .","title":"Estimating area using random numbers"},{"location":"ch6_montecarlo/#monte-carlo-integration","text":"","title":"Monte Carlo Integration"},{"location":"ch6_montecarlo/#markov-chain-monte-carlo-mcmc","text":"","title":"Markov Chain Monte Carlo (MCMC)"},{"location":"ch6_montecarlo/#examples","text":"","title":"Examples"},{"location":"ch7_mltools/","text":"Machine Learning Tools Classification using ready-made ML tools Example","title":"Machine Learning Tools"},{"location":"ch7_mltools/#machine-learning-tools","text":"","title":"Machine Learning Tools"},{"location":"ch7_mltools/#classification-using-ready-made-ml-tools","text":"","title":"Classification using ready-made ML tools"},{"location":"ch7_mltools/#example","text":"","title":"Example"},{"location":"references/","text":"Resources for further reading and reference Books Numerical Methods in Physics with Python by Alex Gezerlis Computational Physics by Mark Newman Numerical Computing with MATLAB by Cleve Moler Tools used to prepare materials and write these notes Markdown Mkdocs Mkdocs material Python Numpy Mathematica Github and github pages Linux Jupyter notebook HTML and Javascript Other useful references Creating Interactive Web Simulations Using HTML5 and JavaScript by Daniel V. Schroeder The Markov-chain Monte Carlo Interactive Gallery by Chi Feng","title":"Resources for further reading and reference"},{"location":"references/#resources-for-further-reading-and-reference","text":"","title":"Resources for further reading and reference"},{"location":"references/#books","text":"Numerical Methods in Physics with Python by Alex Gezerlis Computational Physics by Mark Newman Numerical Computing with MATLAB by Cleve Moler","title":"Books"},{"location":"references/#tools-used-to-prepare-materials-and-write-these-notes","text":"Markdown Mkdocs Mkdocs material Python Numpy Mathematica Github and github pages Linux Jupyter notebook HTML and Javascript","title":"Tools used to prepare materials and write these notes"},{"location":"references/#other-useful-references","text":"Creating Interactive Web Simulations Using HTML5 and JavaScript by Daniel V. Schroeder The Markov-chain Monte Carlo Interactive Gallery by Chi Feng","title":"Other useful references"}]}